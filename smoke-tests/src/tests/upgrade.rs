use std::{process::Command};

use zapatos_smoke_test::smoke_test_environment::{
  new_local_swarm_with_release,
};
use libra_framework::release::ReleaseTarget;
use zapatos_forge::Swarm;
use std::path::PathBuf;
// use zapatos_crypto::traits::ValidCryptoMaterialStringExt;
use std::process::Stdio;
use libra_cached_packages::aptos_stdlib::aptos_governance_create_proposal_v2;
use zapatos_sdk::types::LocalAccount;
#[tokio::test]
async fn can_submit_proposal() {

    let release = ReleaseTarget::Head.load_bundle().unwrap();

    let mut swarm = new_local_swarm_with_release(4, release).await;

    let v = swarm.validators_mut().next().unwrap();
    let pri_key = v.account_private_key().as_ref().unwrap();
    
    let address = v.peer_id().to_owned();
    let mut account = LocalAccount::new(v.peer_id(), pri_key.private_key(), 0);
    
    let proposal_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("src").join("tests").join("fixtures").join("example_proposal_script").join("script.mv");
    dbg!(&proposal_path);
    assert!(&proposal_path.exists());

    let proposal_hash_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("src").join("tests").join("fixtures").join("example_proposal_script").join("script_sha3");
    assert!(&proposal_hash_path.exists());

    // note: this proposal hash was generated by the
    // framework::main::upgrade path and added here to test fixtures.
    let proposal_hash = std::fs::read(proposal_hash_path).unwrap();
    dbg!(&proposal_hash);
    
    let payload = aptos_governance_create_proposal_v2(
        v.peer_id(),
        proposal_hash,
        "metadata url".to_string().as_bytes().to_vec(),
        "metadata struct".to_string().as_bytes().to_vec(),
        true,
    );

    let mut public_info: zapatos_forge::AptosPublicInfo = swarm.aptos_public_info();

    let txn = account.sign_with_transaction_builder(
        public_info.transaction_factory()
            .payload(payload),
    );

    let res = public_info.client().submit_and_wait(&txn).await.unwrap();
    dbg!(&res);

    // check the network still runs
    // check_create_mint_transfer(&mut env).await;
}
