// Copyright Â© Diem Foundation
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Diem transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `diem-sdk-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(clippy::too_many_arguments)]
use diem_types::{
    account_address::AccountAddress,
    transaction::{EntryFunction, TransactionPayload},
};
use move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {
    /// Offers rotation capability on behalf of `account` to the account at address `recipient_address`.
    /// An account can delegate its rotation capability to only one other address at one time. If the account
    /// has an existing rotation capability offer, calling this function will update the rotation capability offer with
    /// the new `recipient_address`.
    /// Here, `rotation_capability_sig_bytes` signature indicates that this key rotation is authorized by the account owner,
    /// and prevents the classic "time-of-check time-of-use" attack.
    /// For example, users usually rely on what the wallet displays to them as the transaction's outcome. Consider a contract that with 50% probability
    /// (based on the current timestamp in Move), rotates somebody's key. The wallet might be unlucky and get an outcome where nothing is rotated,
    /// incorrectly telling the user nothing bad will happen. But when the transaction actually gets executed, the attacker gets lucky and
    /// the execution path triggers the account key rotation.
    /// We prevent such attacks by asking for this extra signature authorizing the key rotation.
    ///
    /// @param rotation_capability_sig_bytes is the signature by the account owner's key on `RotationCapabilityOfferProofChallengeV2`.
    /// @param account_scheme is the scheme of the account (ed25519 or multi_ed25519).
    /// @param account_public_key_bytes is the public key of the account owner.
    /// @param recipient_address is the address of the recipient of the rotation capability - note that if there's an existing rotation capability
    /// offer, calling this function will replace the previous `recipient_address` upon successful verification.
    AccountOfferRotationCapability {
        rotation_capability_sig_bytes: Vec<u8>,
        account_scheme: u8,
        account_public_key_bytes: Vec<u8>,
        recipient_address: AccountAddress,
    },

    /// Revoke the rotation capability offer given to `to_be_revoked_recipient_address` from `account`
    /// Entry function necessary for account key rotation.
    AccountRevokeRotationCapability {
        to_be_revoked_address: AccountAddress,
    },

    /// Generic authentication key rotation function that allows the user to rotate their authentication key from any scheme to any scheme.
    /// To authorize the rotation, we need two signatures:
    /// - the first signature `cap_rotate_key` refers to the signature by the account owner's current key on a valid `RotationProofChallenge`,
    /// demonstrating that the user intends to and has the capability to rotate the authentication key of this account;
    /// - the second signature `cap_update_table` refers to the signature by the new key (that the account owner wants to rotate to) on a
    /// valid `RotationProofChallenge`, demonstrating that the user owns the new private key, and has the authority to update the
    /// `OriginatingAddress` map with the new address mapping `<new_address, originating_address>`.
    /// To verify these two signatures, we need their corresponding public key and public key scheme: we use `from_scheme` and `from_public_key_bytes`
    /// to verify `cap_rotate_key`, and `to_scheme` and `to_public_key_bytes` to verify `cap_update_table`.
    /// A scheme of 0 refers to an Ed25519 key and a scheme of 1 refers to Multi-Ed25519 keys.
    /// `originating address` refers to an account's original/first address.
    ///
    /// Here is an example attack if we don't ask for the second signature `cap_update_table`:
    /// Alice has rotated her account `addr_a` to `new_addr_a`. As a result, the following entry is created, to help Alice when recovering her wallet:
    /// `OriginatingAddress[new_addr_a]` -> `addr_a`
    /// Alice has had bad day: her laptop blew up and she needs to reset her account on a new one.
    /// (Fortunately, she still has her secret key `new_sk_a` associated with her new address `new_addr_a`, so she can do this.)
    ///
    /// But Bob likes to mess with Alice.
    /// Bob creates an account `addr_b` and maliciously rotates it to Alice's new address `new_addr_a`. Since we are no longer checking a PoK,
    /// Bob can easily do this.
    ///
    /// Now, the table will be updated to make Alice's new address point to Bob's address: `OriginatingAddress[new_addr_a]` -> `addr_b`.
    /// When Alice recovers her account, her wallet will display the attacker's address (Bob's) `addr_b` as her address.
    /// Now Alice will give `addr_b` to everyone to pay her, but the money will go to Bob.
    ///
    /// Because we ask for a valid `cap_update_table`, this kind of attack is not possible. Bob would not have the secret key of Alice's address
    /// to rotate his address to Alice's address in the first place.
    /// Public entry function require for TXS cli to provide the
    /// rotation proof and capability.
    AccountRotateAuthenticationKey {
        from_scheme: u8,
        from_public_key_bytes: Vec<u8>,
        to_scheme: u8,
        to_public_key_bytes: Vec<u8>,
        cap_rotate_key: Vec<u8>,
        cap_update_table: Vec<u8>,
    },

    /// Final step in rotating account keys
    /// A user with the capability offer, can now set
    /// a new key.
    /// Entry function necessary for txs CLI rotation of keys
    AccountRotateAuthenticationKeyWithRotationCapability {
        rotation_cap_offerer_address: AccountAddress,
        new_scheme: u8,
        new_public_key_bytes: Vec<u8>,
        cap_update_table: Vec<u8>,
    },

    /// User opts into burns being sent to community (recycle burn).
    /// default is false (burn is final).
    BurnSetSendCommunity {
        community: bool,
    },

    /// Same as `publish_package` but as an entry function which can be called as a transaction. Because
    /// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
    CodePublishPackageTxn {
        metadata_serialized: Vec<u8>,
        code: Vec<Vec<u8>>,
    },

    /// Transfers `amount` of coins `CoinType` from `from` to `to`.
    CoinTransfer {
        coin_type: TypeTag,
        to: AccountAddress,
        amount: u64,
    },

    /// TODO: Allow to propose change only on the signature threshold
    /// Add or remove a signer to/from the multisig, and check if they may be related in the ancestry tree
    CommunityWalletInitChangeSignerCommunityMultisig {
        multisig_address: AccountAddress,
        new_signer: AccountAddress,
        is_add_operation: bool,
        n_of_m: u64,
        vote_duration_epochs: u64,
    },

    /// convenience function to check if the account can be caged
    /// after all the structs are in place
    CommunityWalletInitFinalizeAndCage {
        num_signers: u64,
    },

    CommunityWalletInitInitCommunity {
        initial_authorities: Vec<AccountAddress>,
        check_threshold: u64,
    },

    /// Propose offer to the multisig, and check if the signers are not related family
    CommunityWalletInitProposeOffer {
        new_signers: Vec<AccountAddress>,
        num_signers: u64,
    },

    /// Create a single-step or multi-step proposal
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
    /// only the exact script with matching hash can be successfully executed.
    DiemGovernanceOlCreateProposalV2 {
        execution_hash: Vec<u8>,
        metadata_location: Vec<u8>,
        metadata_hash: Vec<u8>,
        is_multi_step_proposal: bool,
    },

    /// Vote on proposal with `proposal_id`.
    DiemGovernanceOlVote {
        proposal_id: u64,
        should_pass: bool,
    },

    DiemGovernanceSmokeTriggerEpoch {},

    /// Any end user can trigger epoch/boundary and reconfiguration
    /// as long as the VM set the BoundaryBit to true.
    /// We do this because we don't want the VM calling complex
    /// logic itself. Any abort would cause a halt.
    /// On the other hand, a user can call the function once the VM
    /// decides the epoch can change. Any error will just cause the
    /// user's transaction to abort, but the chain will continue.
    /// Whatever fix is needed can be done online with on-chain governance.
    /// Public function for production triggering of epoch boundary.
    DiemGovernanceTriggerEpoch {},

    /// Standalone function to close the poll after threshold or expiration passed
    /// The reason for a separate function is so that closing the poll and
    /// voting may not need to be in the same transaction. They can be atomic
    /// and produce better error messages.
    DonorVoiceTxsMaybeTallyReauthTx {
        multisig_address: AccountAddress,
    },

    /// A signer of the multisig can propose a payment
    /// Public entry function required for txs cli
    DonorVoiceTxsProposeAdvanceTx {
        multisig_address: AccountAddress,
        payee: AccountAddress,
        value: u64,
        description: Vec<u8>,
    },

    /// A donor can propose the liquidation of a Donor Voice account
    /// Public entry function required for txs cli.
    DonorVoiceTxsProposeLiquidateTx {
        multisig_address: AccountAddress,
    },

    /// A signer of the multisig can propose a payment
    /// Public entry function required for txs cli.
    DonorVoiceTxsProposePaymentTx {
        multisig_address: AccountAddress,
        payee: AccountAddress,
        value: u64,
        description: Vec<u8>,
    },

    /// A donor of the program can propose a veto
    /// Public entry function required for txs cli.
    DonorVoiceTxsProposeVetoTx {
        multisig_address: AccountAddress,
        id: u64,
    },

    /// After proposed, subsequent voters call this to vote liquidation
    DonorVoiceTxsVoteLiquidationTx {
        multisig_address: AccountAddress,
    },

    /// After proposed, subsequent donors can vote to reauth an account
    /// Public entry function required for txs cli.
    DonorVoiceTxsVoteReauthTx {
        multisig_address: AccountAddress,
    },

    /// testnet helper to allow testnet root account to set flip the boundary bit
    /// used for testing cli tools for polling and triggering
    /// Public entry function necessary for smoke tests.
    EpochBoundarySmokeEnableTrigger {},

    EpochBoundarySmokeTriggerEpoch {},

    FiloMigrationMaybeMigrate {},

    /// Only a Voucher of the validator can flip the unjail bit.
    /// This is a way to make sure the validator is ready to rejoin.
    JailUnjailByVoucher {
        addr: AccountAddress,
    },

    /// Root account can mint to an address. Only used for genesis and tests.
    /// The "root" account in smoke tests has some privileges.
    LibraCoinMintToImpl {
        dst_addr: AccountAddress,
        amount: u64,
    },

    MultiActionClaimOffer {
        multisig_address: AccountAddress,
    },

    MultiActionInitGovDeprecated {},

    /// Similar to add_owners, but only allow adding one owner.
    MultisigAccountAddOwner {
        new_owner: AccountAddress,
    },

    /// Add new owners to the multisig account. This can only be invoked by the multisig account itself, through the
    /// proposal flow.
    ///
    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
    /// maliciously alter the owners list.
    MultisigAccountAddOwners {
        new_owners: Vec<AccountAddress>,
    },

    /// Similar to remove_owners, but only allow removing one owner.
    MultisigAccountRemoveOwner {
        owner_to_remove: AccountAddress,
    },

    /// Remove owners from the multisig account. This can only be invoked by the multisig account itself, through the
    /// proposal flow.
    ///
    /// This function skips any owners who are not in the multisig account's list of owners.
    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
    /// maliciously alter the owners list.
    MultisigAccountRemoveOwners {
        owners_to_remove: Vec<AccountAddress>,
    },

    /// Allow the multisig account to update its own metadata. Note that this overrides the entire existing metadata.
    /// If any attributes are not specified in the metadata, they will be removed!
    ///
    /// This can only be invoked by the multisig account itself, through the proposal flow.
    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
    /// maliciously alter the number of signatures required.
    MultisigAccountUpdateMetadata {
        keys: Vec<Vec<u8>>,
        values: Vec<Vec<u8>>,
    },

    /// Update the number of signatures required to execute transaction in the specified multisig account.
    ///
    /// This can only be invoked by the multisig account itself, through the proposal flow.
    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
    /// maliciously alter the number of signatures required.
    MultisigAccountUpdateSignaturesRequired {
        new_num_signatures_required: u64,
    },

    /// Helper for smoke tests to create accounts.
    /// this is in production code because:
    /// it is used for genesis transactions regarding mainnet
    /// e.g. test_correct_supply_arithmetic_single
    /// plus, a  #[test_only] pragma will not work for smoke tests
    /// Belt and suspenders
    OlAccountCreateAccount {
        auth_key: AccountAddress,
    },

    /// Convenient function to transfer GAS to a recipient account that might not exist.
    /// This would create the recipient account first, which also registers it to receive GAS, before transferring.
    OlAccountTransfer {
        to: AccountAddress,
        amount: u64,
    },

    /// retract bid
    ProofOfFeePofRetractBid {},

    /// update the bid for the sender
    ProofOfFeePofUpdateBid {
        bid: u64,
        epoch_expiry: u64,
    },

    /// update the bid using estimated net reward instead of the internal bid variables
    /// Public entry function needed for txs cli.
    ProofOfFeePofUpdateBidNetReward {
        net_reward: u64,
        epoch_expiry: u64,
    },

    SlowWalletSmokeTestVmUnlock {
        user_addr: AccountAddress,
        unlocked: u64,
        transferred: u64,
    },

    /// Users can change their account to slow, by calling the entry function
    /// Warning: this is permanent for the account. There's no way to
    /// reverse a "slow wallet".
    SlowWalletUserSetSlow {},

    /// Initialize the validator account and give ownership to the signing account.
    StakeInitializeValidator {
        consensus_pubkey: Vec<u8>,
        proof_of_possession: Vec<u8>,
        network_addresses: Vec<u8>,
        fullnode_addresses: Vec<u8>,
    },

    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
    /// Entry function necessary for validator configuration
    StakeUpdateNetworkAndFullnodeAddresses {
        validator_address: AccountAddress,
        new_network_addresses: Vec<u8>,
        new_fullnode_addresses: Vec<u8>,
    },

    /// This is the entrypoint for a validator joining the network.
    /// Separates the logic of registration from validator election etc. (in stake.move).
    /// This prevents dependency cycling issues, since stake.move is a large module.
    ValidatorUniverseRegisterValidator {
        consensus_pubkey: Vec<u8>,
        proof_of_possession: Vec<u8>,
        network_addresses: Vec<u8>,
        fullnode_addresses: Vec<u8>,
    },

    VouchTxsCleanExpired {},

    VouchTxsRevoke {
        friend_account: AccountAddress,
    },

    VouchTxsVouchFor {
        friend_account: AccountAddress,
    },
}

impl EntryFunctionCall {
    /// Build an Diem `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            AccountOfferRotationCapability {
                rotation_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            } => account_offer_rotation_capability(
                rotation_capability_sig_bytes,
                account_scheme,
                account_public_key_bytes,
                recipient_address,
            ),
            AccountRevokeRotationCapability {
                to_be_revoked_address,
            } => account_revoke_rotation_capability(to_be_revoked_address),
            AccountRotateAuthenticationKey {
                from_scheme,
                from_public_key_bytes,
                to_scheme,
                to_public_key_bytes,
                cap_rotate_key,
                cap_update_table,
            } => account_rotate_authentication_key(
                from_scheme,
                from_public_key_bytes,
                to_scheme,
                to_public_key_bytes,
                cap_rotate_key,
                cap_update_table,
            ),
            AccountRotateAuthenticationKeyWithRotationCapability {
                rotation_cap_offerer_address,
                new_scheme,
                new_public_key_bytes,
                cap_update_table,
            } => account_rotate_authentication_key_with_rotation_capability(
                rotation_cap_offerer_address,
                new_scheme,
                new_public_key_bytes,
                cap_update_table,
            ),
            BurnSetSendCommunity { community } => burn_set_send_community(community),
            CodePublishPackageTxn {
                metadata_serialized,
                code,
            } => code_publish_package_txn(metadata_serialized, code),
            CoinTransfer {
                coin_type,
                to,
                amount,
            } => coin_transfer(coin_type, to, amount),
            CommunityWalletInitChangeSignerCommunityMultisig {
                multisig_address,
                new_signer,
                is_add_operation,
                n_of_m,
                vote_duration_epochs,
            } => community_wallet_init_change_signer_community_multisig(
                multisig_address,
                new_signer,
                is_add_operation,
                n_of_m,
                vote_duration_epochs,
            ),
            CommunityWalletInitFinalizeAndCage { num_signers } => {
                community_wallet_init_finalize_and_cage(num_signers)
            }
            CommunityWalletInitInitCommunity {
                initial_authorities,
                check_threshold,
            } => community_wallet_init_init_community(initial_authorities, check_threshold),
            CommunityWalletInitProposeOffer {
                new_signers,
                num_signers,
            } => community_wallet_init_propose_offer(new_signers, num_signers),
            DiemGovernanceOlCreateProposalV2 {
                execution_hash,
                metadata_location,
                metadata_hash,
                is_multi_step_proposal,
            } => diem_governance_ol_create_proposal_v2(
                execution_hash,
                metadata_location,
                metadata_hash,
                is_multi_step_proposal,
            ),
            DiemGovernanceOlVote {
                proposal_id,
                should_pass,
            } => diem_governance_ol_vote(proposal_id, should_pass),
            DiemGovernanceSmokeTriggerEpoch {} => diem_governance_smoke_trigger_epoch(),
            DiemGovernanceTriggerEpoch {} => diem_governance_trigger_epoch(),
            DonorVoiceTxsMaybeTallyReauthTx { multisig_address } => {
                donor_voice_txs_maybe_tally_reauth_tx(multisig_address)
            }
            DonorVoiceTxsProposeAdvanceTx {
                multisig_address,
                payee,
                value,
                description,
            } => donor_voice_txs_propose_advance_tx(multisig_address, payee, value, description),
            DonorVoiceTxsProposeLiquidateTx { multisig_address } => {
                donor_voice_txs_propose_liquidate_tx(multisig_address)
            }
            DonorVoiceTxsProposePaymentTx {
                multisig_address,
                payee,
                value,
                description,
            } => donor_voice_txs_propose_payment_tx(multisig_address, payee, value, description),
            DonorVoiceTxsProposeVetoTx {
                multisig_address,
                id,
            } => donor_voice_txs_propose_veto_tx(multisig_address, id),
            DonorVoiceTxsVoteLiquidationTx { multisig_address } => {
                donor_voice_txs_vote_liquidation_tx(multisig_address)
            }
            DonorVoiceTxsVoteReauthTx { multisig_address } => {
                donor_voice_txs_vote_reauth_tx(multisig_address)
            }
            EpochBoundarySmokeEnableTrigger {} => epoch_boundary_smoke_enable_trigger(),
            EpochBoundarySmokeTriggerEpoch {} => epoch_boundary_smoke_trigger_epoch(),
            FiloMigrationMaybeMigrate {} => filo_migration_maybe_migrate(),
            JailUnjailByVoucher { addr } => jail_unjail_by_voucher(addr),
            LibraCoinMintToImpl { dst_addr, amount } => libra_coin_mint_to_impl(dst_addr, amount),
            MultiActionClaimOffer { multisig_address } => {
                multi_action_claim_offer(multisig_address)
            }
            MultiActionInitGovDeprecated {} => multi_action_init_gov_deprecated(),
            MultisigAccountAddOwner { new_owner } => multisig_account_add_owner(new_owner),
            MultisigAccountAddOwners { new_owners } => multisig_account_add_owners(new_owners),
            MultisigAccountRemoveOwner { owner_to_remove } => {
                multisig_account_remove_owner(owner_to_remove)
            }
            MultisigAccountRemoveOwners { owners_to_remove } => {
                multisig_account_remove_owners(owners_to_remove)
            }
            MultisigAccountUpdateMetadata { keys, values } => {
                multisig_account_update_metadata(keys, values)
            }
            MultisigAccountUpdateSignaturesRequired {
                new_num_signatures_required,
            } => multisig_account_update_signatures_required(new_num_signatures_required),
            OlAccountCreateAccount { auth_key } => ol_account_create_account(auth_key),
            OlAccountTransfer { to, amount } => ol_account_transfer(to, amount),
            ProofOfFeePofRetractBid {} => proof_of_fee_pof_retract_bid(),
            ProofOfFeePofUpdateBid { bid, epoch_expiry } => {
                proof_of_fee_pof_update_bid(bid, epoch_expiry)
            }
            ProofOfFeePofUpdateBidNetReward {
                net_reward,
                epoch_expiry,
            } => proof_of_fee_pof_update_bid_net_reward(net_reward, epoch_expiry),
            SlowWalletSmokeTestVmUnlock {
                user_addr,
                unlocked,
                transferred,
            } => slow_wallet_smoke_test_vm_unlock(user_addr, unlocked, transferred),
            SlowWalletUserSetSlow {} => slow_wallet_user_set_slow(),
            StakeInitializeValidator {
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            } => stake_initialize_validator(
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            ),
            StakeUpdateNetworkAndFullnodeAddresses {
                validator_address,
                new_network_addresses,
                new_fullnode_addresses,
            } => stake_update_network_and_fullnode_addresses(
                validator_address,
                new_network_addresses,
                new_fullnode_addresses,
            ),
            ValidatorUniverseRegisterValidator {
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            } => validator_universe_register_validator(
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            ),
            VouchTxsCleanExpired {} => vouch_txs_clean_expired(),
            VouchTxsRevoke { friend_account } => vouch_txs_revoke(friend_account),
            VouchTxsVouchFor { friend_account } => vouch_txs_vouch_for(friend_account),
        }
    }

    /// Try to recognize an Diem `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// Offers rotation capability on behalf of `account` to the account at address `recipient_address`.
/// An account can delegate its rotation capability to only one other address at one time. If the account
/// has an existing rotation capability offer, calling this function will update the rotation capability offer with
/// the new `recipient_address`.
/// Here, `rotation_capability_sig_bytes` signature indicates that this key rotation is authorized by the account owner,
/// and prevents the classic "time-of-check time-of-use" attack.
/// For example, users usually rely on what the wallet displays to them as the transaction's outcome. Consider a contract that with 50% probability
/// (based on the current timestamp in Move), rotates somebody's key. The wallet might be unlucky and get an outcome where nothing is rotated,
/// incorrectly telling the user nothing bad will happen. But when the transaction actually gets executed, the attacker gets lucky and
/// the execution path triggers the account key rotation.
/// We prevent such attacks by asking for this extra signature authorizing the key rotation.
///
/// @param rotation_capability_sig_bytes is the signature by the account owner's key on `RotationCapabilityOfferProofChallengeV2`.
/// @param account_scheme is the scheme of the account (ed25519 or multi_ed25519).
/// @param account_public_key_bytes is the public key of the account owner.
/// @param recipient_address is the address of the recipient of the rotation capability - note that if there's an existing rotation capability
/// offer, calling this function will replace the previous `recipient_address` upon successful verification.
pub fn account_offer_rotation_capability(
    rotation_capability_sig_bytes: Vec<u8>,
    account_scheme: u8,
    account_public_key_bytes: Vec<u8>,
    recipient_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("offer_rotation_capability").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&rotation_capability_sig_bytes).unwrap(),
            bcs::to_bytes(&account_scheme).unwrap(),
            bcs::to_bytes(&account_public_key_bytes).unwrap(),
            bcs::to_bytes(&recipient_address).unwrap(),
        ],
    ))
}

/// Revoke the rotation capability offer given to `to_be_revoked_recipient_address` from `account`
/// Entry function necessary for account key rotation.
pub fn account_revoke_rotation_capability(
    to_be_revoked_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("revoke_rotation_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to_be_revoked_address).unwrap()],
    ))
}

/// Generic authentication key rotation function that allows the user to rotate their authentication key from any scheme to any scheme.
/// To authorize the rotation, we need two signatures:
/// - the first signature `cap_rotate_key` refers to the signature by the account owner's current key on a valid `RotationProofChallenge`,
/// demonstrating that the user intends to and has the capability to rotate the authentication key of this account;
/// - the second signature `cap_update_table` refers to the signature by the new key (that the account owner wants to rotate to) on a
/// valid `RotationProofChallenge`, demonstrating that the user owns the new private key, and has the authority to update the
/// `OriginatingAddress` map with the new address mapping `<new_address, originating_address>`.
/// To verify these two signatures, we need their corresponding public key and public key scheme: we use `from_scheme` and `from_public_key_bytes`
/// to verify `cap_rotate_key`, and `to_scheme` and `to_public_key_bytes` to verify `cap_update_table`.
/// A scheme of 0 refers to an Ed25519 key and a scheme of 1 refers to Multi-Ed25519 keys.
/// `originating address` refers to an account's original/first address.
///
/// Here is an example attack if we don't ask for the second signature `cap_update_table`:
/// Alice has rotated her account `addr_a` to `new_addr_a`. As a result, the following entry is created, to help Alice when recovering her wallet:
/// `OriginatingAddress[new_addr_a]` -> `addr_a`
/// Alice has had bad day: her laptop blew up and she needs to reset her account on a new one.
/// (Fortunately, she still has her secret key `new_sk_a` associated with her new address `new_addr_a`, so she can do this.)
///
/// But Bob likes to mess with Alice.
/// Bob creates an account `addr_b` and maliciously rotates it to Alice's new address `new_addr_a`. Since we are no longer checking a PoK,
/// Bob can easily do this.
///
/// Now, the table will be updated to make Alice's new address point to Bob's address: `OriginatingAddress[new_addr_a]` -> `addr_b`.
/// When Alice recovers her account, her wallet will display the attacker's address (Bob's) `addr_b` as her address.
/// Now Alice will give `addr_b` to everyone to pay her, but the money will go to Bob.
///
/// Because we ask for a valid `cap_update_table`, this kind of attack is not possible. Bob would not have the secret key of Alice's address
/// to rotate his address to Alice's address in the first place.
/// Public entry function require for TXS cli to provide the
/// rotation proof and capability.
pub fn account_rotate_authentication_key(
    from_scheme: u8,
    from_public_key_bytes: Vec<u8>,
    to_scheme: u8,
    to_public_key_bytes: Vec<u8>,
    cap_rotate_key: Vec<u8>,
    cap_update_table: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&from_scheme).unwrap(),
            bcs::to_bytes(&from_public_key_bytes).unwrap(),
            bcs::to_bytes(&to_scheme).unwrap(),
            bcs::to_bytes(&to_public_key_bytes).unwrap(),
            bcs::to_bytes(&cap_rotate_key).unwrap(),
            bcs::to_bytes(&cap_update_table).unwrap(),
        ],
    ))
}

/// Final step in rotating account keys
/// A user with the capability offer, can now set
/// a new key.
/// Entry function necessary for txs CLI rotation of keys
pub fn account_rotate_authentication_key_with_rotation_capability(
    rotation_cap_offerer_address: AccountAddress,
    new_scheme: u8,
    new_public_key_bytes: Vec<u8>,
    cap_update_table: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key_with_rotation_capability").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&rotation_cap_offerer_address).unwrap(),
            bcs::to_bytes(&new_scheme).unwrap(),
            bcs::to_bytes(&new_public_key_bytes).unwrap(),
            bcs::to_bytes(&cap_update_table).unwrap(),
        ],
    ))
}

/// User opts into burns being sent to community (recycle burn).
/// default is false (burn is final).
pub fn burn_set_send_community(community: bool) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("burn").to_owned(),
        ),
        ident_str!("set_send_community").to_owned(),
        vec![],
        vec![bcs::to_bytes(&community).unwrap()],
    ))
}

/// Same as `publish_package` but as an entry function which can be called as a transaction. Because
/// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
pub fn code_publish_package_txn(
    metadata_serialized: Vec<u8>,
    code: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("code").to_owned(),
        ),
        ident_str!("publish_package_txn").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_serialized).unwrap(),
            bcs::to_bytes(&code).unwrap(),
        ],
    ))
}

/// Transfers `amount` of coins `CoinType` from `from` to `to`.
pub fn coin_transfer(coin_type: TypeTag, to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// TODO: Allow to propose change only on the signature threshold
/// Add or remove a signer to/from the multisig, and check if they may be related in the ancestry tree
pub fn community_wallet_init_change_signer_community_multisig(
    multisig_address: AccountAddress,
    new_signer: AccountAddress,
    is_add_operation: bool,
    n_of_m: u64,
    vote_duration_epochs: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("community_wallet_init").to_owned(),
        ),
        ident_str!("change_signer_community_multisig").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&multisig_address).unwrap(),
            bcs::to_bytes(&new_signer).unwrap(),
            bcs::to_bytes(&is_add_operation).unwrap(),
            bcs::to_bytes(&n_of_m).unwrap(),
            bcs::to_bytes(&vote_duration_epochs).unwrap(),
        ],
    ))
}

/// convenience function to check if the account can be caged
/// after all the structs are in place
pub fn community_wallet_init_finalize_and_cage(num_signers: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("community_wallet_init").to_owned(),
        ),
        ident_str!("finalize_and_cage").to_owned(),
        vec![],
        vec![bcs::to_bytes(&num_signers).unwrap()],
    ))
}

pub fn community_wallet_init_init_community(
    initial_authorities: Vec<AccountAddress>,
    check_threshold: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("community_wallet_init").to_owned(),
        ),
        ident_str!("init_community").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&initial_authorities).unwrap(),
            bcs::to_bytes(&check_threshold).unwrap(),
        ],
    ))
}

/// Propose offer to the multisig, and check if the signers are not related family
pub fn community_wallet_init_propose_offer(
    new_signers: Vec<AccountAddress>,
    num_signers: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("community_wallet_init").to_owned(),
        ),
        ident_str!("propose_offer").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&new_signers).unwrap(),
            bcs::to_bytes(&num_signers).unwrap(),
        ],
    ))
}

/// Create a single-step or multi-step proposal
/// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
/// only the exact script with matching hash can be successfully executed.
pub fn diem_governance_ol_create_proposal_v2(
    execution_hash: Vec<u8>,
    metadata_location: Vec<u8>,
    metadata_hash: Vec<u8>,
    is_multi_step_proposal: bool,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("diem_governance").to_owned(),
        ),
        ident_str!("ol_create_proposal_v2").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&execution_hash).unwrap(),
            bcs::to_bytes(&metadata_location).unwrap(),
            bcs::to_bytes(&metadata_hash).unwrap(),
            bcs::to_bytes(&is_multi_step_proposal).unwrap(),
        ],
    ))
}

/// Vote on proposal with `proposal_id`.
pub fn diem_governance_ol_vote(proposal_id: u64, should_pass: bool) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("diem_governance").to_owned(),
        ),
        ident_str!("ol_vote").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&proposal_id).unwrap(),
            bcs::to_bytes(&should_pass).unwrap(),
        ],
    ))
}

pub fn diem_governance_smoke_trigger_epoch() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("diem_governance").to_owned(),
        ),
        ident_str!("smoke_trigger_epoch").to_owned(),
        vec![],
        vec![],
    ))
}

/// Any end user can trigger epoch/boundary and reconfiguration
/// as long as the VM set the BoundaryBit to true.
/// We do this because we don't want the VM calling complex
/// logic itself. Any abort would cause a halt.
/// On the other hand, a user can call the function once the VM
/// decides the epoch can change. Any error will just cause the
/// user's transaction to abort, but the chain will continue.
/// Whatever fix is needed can be done online with on-chain governance.
/// Public function for production triggering of epoch boundary.
pub fn diem_governance_trigger_epoch() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("diem_governance").to_owned(),
        ),
        ident_str!("trigger_epoch").to_owned(),
        vec![],
        vec![],
    ))
}

/// Standalone function to close the poll after threshold or expiration passed
/// The reason for a separate function is so that closing the poll and
/// voting may not need to be in the same transaction. They can be atomic
/// and produce better error messages.
pub fn donor_voice_txs_maybe_tally_reauth_tx(
    multisig_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("donor_voice_txs").to_owned(),
        ),
        ident_str!("maybe_tally_reauth_tx").to_owned(),
        vec![],
        vec![bcs::to_bytes(&multisig_address).unwrap()],
    ))
}

/// A signer of the multisig can propose a payment
/// Public entry function required for txs cli
pub fn donor_voice_txs_propose_advance_tx(
    multisig_address: AccountAddress,
    payee: AccountAddress,
    value: u64,
    description: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("donor_voice_txs").to_owned(),
        ),
        ident_str!("propose_advance_tx").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&multisig_address).unwrap(),
            bcs::to_bytes(&payee).unwrap(),
            bcs::to_bytes(&value).unwrap(),
            bcs::to_bytes(&description).unwrap(),
        ],
    ))
}

/// A donor can propose the liquidation of a Donor Voice account
/// Public entry function required for txs cli.
pub fn donor_voice_txs_propose_liquidate_tx(
    multisig_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("donor_voice_txs").to_owned(),
        ),
        ident_str!("propose_liquidate_tx").to_owned(),
        vec![],
        vec![bcs::to_bytes(&multisig_address).unwrap()],
    ))
}

/// A signer of the multisig can propose a payment
/// Public entry function required for txs cli.
pub fn donor_voice_txs_propose_payment_tx(
    multisig_address: AccountAddress,
    payee: AccountAddress,
    value: u64,
    description: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("donor_voice_txs").to_owned(),
        ),
        ident_str!("propose_payment_tx").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&multisig_address).unwrap(),
            bcs::to_bytes(&payee).unwrap(),
            bcs::to_bytes(&value).unwrap(),
            bcs::to_bytes(&description).unwrap(),
        ],
    ))
}

/// A donor of the program can propose a veto
/// Public entry function required for txs cli.
pub fn donor_voice_txs_propose_veto_tx(
    multisig_address: AccountAddress,
    id: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("donor_voice_txs").to_owned(),
        ),
        ident_str!("propose_veto_tx").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&multisig_address).unwrap(),
            bcs::to_bytes(&id).unwrap(),
        ],
    ))
}

/// After proposed, subsequent voters call this to vote liquidation
pub fn donor_voice_txs_vote_liquidation_tx(multisig_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("donor_voice_txs").to_owned(),
        ),
        ident_str!("vote_liquidation_tx").to_owned(),
        vec![],
        vec![bcs::to_bytes(&multisig_address).unwrap()],
    ))
}

/// After proposed, subsequent donors can vote to reauth an account
/// Public entry function required for txs cli.
pub fn donor_voice_txs_vote_reauth_tx(multisig_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("donor_voice_txs").to_owned(),
        ),
        ident_str!("vote_reauth_tx").to_owned(),
        vec![],
        vec![bcs::to_bytes(&multisig_address).unwrap()],
    ))
}

/// testnet helper to allow testnet root account to set flip the boundary bit
/// used for testing cli tools for polling and triggering
/// Public entry function necessary for smoke tests.
pub fn epoch_boundary_smoke_enable_trigger() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("epoch_boundary").to_owned(),
        ),
        ident_str!("smoke_enable_trigger").to_owned(),
        vec![],
        vec![],
    ))
}

pub fn epoch_boundary_smoke_trigger_epoch() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("epoch_boundary").to_owned(),
        ),
        ident_str!("smoke_trigger_epoch").to_owned(),
        vec![],
        vec![],
    ))
}

pub fn filo_migration_maybe_migrate() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("filo_migration").to_owned(),
        ),
        ident_str!("maybe_migrate").to_owned(),
        vec![],
        vec![],
    ))
}

/// Only a Voucher of the validator can flip the unjail bit.
/// This is a way to make sure the validator is ready to rejoin.
pub fn jail_unjail_by_voucher(addr: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("jail").to_owned(),
        ),
        ident_str!("unjail_by_voucher").to_owned(),
        vec![],
        vec![bcs::to_bytes(&addr).unwrap()],
    ))
}

/// Root account can mint to an address. Only used for genesis and tests.
/// The "root" account in smoke tests has some privileges.
pub fn libra_coin_mint_to_impl(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("libra_coin").to_owned(),
        ),
        ident_str!("mint_to_impl").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn multi_action_claim_offer(multisig_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multi_action").to_owned(),
        ),
        ident_str!("claim_offer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&multisig_address).unwrap()],
    ))
}

pub fn multi_action_init_gov_deprecated() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multi_action").to_owned(),
        ),
        ident_str!("init_gov_deprecated").to_owned(),
        vec![],
        vec![],
    ))
}

/// Similar to add_owners, but only allow adding one owner.
pub fn multisig_account_add_owner(new_owner: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("add_owner").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_owner).unwrap()],
    ))
}

/// Add new owners to the multisig account. This can only be invoked by the multisig account itself, through the
/// proposal flow.
///
/// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
/// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
/// maliciously alter the owners list.
pub fn multisig_account_add_owners(new_owners: Vec<AccountAddress>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("add_owners").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_owners).unwrap()],
    ))
}

/// Similar to remove_owners, but only allow removing one owner.
pub fn multisig_account_remove_owner(owner_to_remove: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("remove_owner").to_owned(),
        vec![],
        vec![bcs::to_bytes(&owner_to_remove).unwrap()],
    ))
}

/// Remove owners from the multisig account. This can only be invoked by the multisig account itself, through the
/// proposal flow.
///
/// This function skips any owners who are not in the multisig account's list of owners.
/// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
/// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
/// maliciously alter the owners list.
pub fn multisig_account_remove_owners(owners_to_remove: Vec<AccountAddress>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("remove_owners").to_owned(),
        vec![],
        vec![bcs::to_bytes(&owners_to_remove).unwrap()],
    ))
}

/// Allow the multisig account to update its own metadata. Note that this overrides the entire existing metadata.
/// If any attributes are not specified in the metadata, they will be removed!
///
/// This can only be invoked by the multisig account itself, through the proposal flow.
/// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
/// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
/// maliciously alter the number of signatures required.
pub fn multisig_account_update_metadata(
    keys: Vec<Vec<u8>>,
    values: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("update_metadata").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&keys).unwrap(),
            bcs::to_bytes(&values).unwrap(),
        ],
    ))
}

/// Update the number of signatures required to execute transaction in the specified multisig account.
///
/// This can only be invoked by the multisig account itself, through the proposal flow.
/// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
/// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
/// maliciously alter the number of signatures required.
pub fn multisig_account_update_signatures_required(
    new_num_signatures_required: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("update_signatures_required").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_num_signatures_required).unwrap()],
    ))
}

/// Helper for smoke tests to create accounts.
/// this is in production code because:
/// it is used for genesis transactions regarding mainnet
/// e.g. test_correct_supply_arithmetic_single
/// plus, a  #[test_only] pragma will not work for smoke tests
/// Belt and suspenders
pub fn ol_account_create_account(auth_key: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("ol_account").to_owned(),
        ),
        ident_str!("create_account").to_owned(),
        vec![],
        vec![bcs::to_bytes(&auth_key).unwrap()],
    ))
}

/// Convenient function to transfer GAS to a recipient account that might not exist.
/// This would create the recipient account first, which also registers it to receive GAS, before transferring.
pub fn ol_account_transfer(to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("ol_account").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// retract bid
pub fn proof_of_fee_pof_retract_bid() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("proof_of_fee").to_owned(),
        ),
        ident_str!("pof_retract_bid").to_owned(),
        vec![],
        vec![],
    ))
}

/// update the bid for the sender
pub fn proof_of_fee_pof_update_bid(bid: u64, epoch_expiry: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("proof_of_fee").to_owned(),
        ),
        ident_str!("pof_update_bid").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&bid).unwrap(),
            bcs::to_bytes(&epoch_expiry).unwrap(),
        ],
    ))
}

/// update the bid using estimated net reward instead of the internal bid variables
/// Public entry function needed for txs cli.
pub fn proof_of_fee_pof_update_bid_net_reward(
    net_reward: u64,
    epoch_expiry: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("proof_of_fee").to_owned(),
        ),
        ident_str!("pof_update_bid_net_reward").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&net_reward).unwrap(),
            bcs::to_bytes(&epoch_expiry).unwrap(),
        ],
    ))
}

pub fn slow_wallet_smoke_test_vm_unlock(
    user_addr: AccountAddress,
    unlocked: u64,
    transferred: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("slow_wallet").to_owned(),
        ),
        ident_str!("smoke_test_vm_unlock").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&user_addr).unwrap(),
            bcs::to_bytes(&unlocked).unwrap(),
            bcs::to_bytes(&transferred).unwrap(),
        ],
    ))
}

/// Users can change their account to slow, by calling the entry function
/// Warning: this is permanent for the account. There's no way to
/// reverse a "slow wallet".
pub fn slow_wallet_user_set_slow() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("slow_wallet").to_owned(),
        ),
        ident_str!("user_set_slow").to_owned(),
        vec![],
        vec![],
    ))
}

/// Initialize the validator account and give ownership to the signing account.
pub fn stake_initialize_validator(
    consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
    network_addresses: Vec<u8>,
    fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("initialize_validator").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&network_addresses).unwrap(),
            bcs::to_bytes(&fullnode_addresses).unwrap(),
        ],
    ))
}

/// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
/// Entry function necessary for validator configuration
pub fn stake_update_network_and_fullnode_addresses(
    validator_address: AccountAddress,
    new_network_addresses: Vec<u8>,
    new_fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("update_network_and_fullnode_addresses").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&validator_address).unwrap(),
            bcs::to_bytes(&new_network_addresses).unwrap(),
            bcs::to_bytes(&new_fullnode_addresses).unwrap(),
        ],
    ))
}

/// This is the entrypoint for a validator joining the network.
/// Separates the logic of registration from validator election etc. (in stake.move).
/// This prevents dependency cycling issues, since stake.move is a large module.
pub fn validator_universe_register_validator(
    consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
    network_addresses: Vec<u8>,
    fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_universe").to_owned(),
        ),
        ident_str!("register_validator").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&network_addresses).unwrap(),
            bcs::to_bytes(&fullnode_addresses).unwrap(),
        ],
    ))
}

pub fn vouch_txs_clean_expired() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("vouch_txs").to_owned(),
        ),
        ident_str!("clean_expired").to_owned(),
        vec![],
        vec![],
    ))
}

pub fn vouch_txs_revoke(friend_account: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("vouch_txs").to_owned(),
        ),
        ident_str!("revoke").to_owned(),
        vec![],
        vec![bcs::to_bytes(&friend_account).unwrap()],
    ))
}

pub fn vouch_txs_vouch_for(friend_account: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("vouch_txs").to_owned(),
        ),
        ident_str!("vouch_for").to_owned(),
        vec![],
        vec![bcs::to_bytes(&friend_account).unwrap()],
    ))
}
mod decoder {
    use super::*;
    pub fn account_offer_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountOfferRotationCapability {
                rotation_capability_sig_bytes: bcs::from_bytes(script.args().get(0)?).ok()?,
                account_scheme: bcs::from_bytes(script.args().get(1)?).ok()?,
                account_public_key_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                recipient_address: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_revoke_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRevokeRotationCapability {
                to_be_revoked_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::AccountRotateAuthenticationKey {
                from_scheme: bcs::from_bytes(script.args().get(0)?).ok()?,
                from_public_key_bytes: bcs::from_bytes(script.args().get(1)?).ok()?,
                to_scheme: bcs::from_bytes(script.args().get(2)?).ok()?,
                to_public_key_bytes: bcs::from_bytes(script.args().get(3)?).ok()?,
                cap_rotate_key: bcs::from_bytes(script.args().get(4)?).ok()?,
                cap_update_table: bcs::from_bytes(script.args().get(5)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key_with_rotation_capability(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::AccountRotateAuthenticationKeyWithRotationCapability {
                    rotation_cap_offerer_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    new_scheme: bcs::from_bytes(script.args().get(1)?).ok()?,
                    new_public_key_bytes: bcs::from_bytes(script.args().get(2)?).ok()?,
                    cap_update_table: bcs::from_bytes(script.args().get(3)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn burn_set_send_community(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::BurnSetSendCommunity {
                community: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn code_publish_package_txn(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CodePublishPackageTxn {
                metadata_serialized: bcs::from_bytes(script.args().get(0)?).ok()?,
                code: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinTransfer {
                coin_type: script.ty_args().get(0)?.clone(),
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn community_wallet_init_change_signer_community_multisig(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::CommunityWalletInitChangeSignerCommunityMultisig {
                    multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    new_signer: bcs::from_bytes(script.args().get(1)?).ok()?,
                    is_add_operation: bcs::from_bytes(script.args().get(2)?).ok()?,
                    n_of_m: bcs::from_bytes(script.args().get(3)?).ok()?,
                    vote_duration_epochs: bcs::from_bytes(script.args().get(4)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn community_wallet_init_finalize_and_cage(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CommunityWalletInitFinalizeAndCage {
                num_signers: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn community_wallet_init_init_community(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CommunityWalletInitInitCommunity {
                initial_authorities: bcs::from_bytes(script.args().get(0)?).ok()?,
                check_threshold: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn community_wallet_init_propose_offer(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CommunityWalletInitProposeOffer {
                new_signers: bcs::from_bytes(script.args().get(0)?).ok()?,
                num_signers: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn diem_governance_ol_create_proposal_v2(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DiemGovernanceOlCreateProposalV2 {
                execution_hash: bcs::from_bytes(script.args().get(0)?).ok()?,
                metadata_location: bcs::from_bytes(script.args().get(1)?).ok()?,
                metadata_hash: bcs::from_bytes(script.args().get(2)?).ok()?,
                is_multi_step_proposal: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn diem_governance_ol_vote(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DiemGovernanceOlVote {
                proposal_id: bcs::from_bytes(script.args().get(0)?).ok()?,
                should_pass: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn diem_governance_smoke_trigger_epoch(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::DiemGovernanceSmokeTriggerEpoch {})
        } else {
            None
        }
    }

    pub fn diem_governance_trigger_epoch(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::DiemGovernanceTriggerEpoch {})
        } else {
            None
        }
    }

    pub fn donor_voice_txs_maybe_tally_reauth_tx(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DonorVoiceTxsMaybeTallyReauthTx {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn donor_voice_txs_propose_advance_tx(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DonorVoiceTxsProposeAdvanceTx {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                payee: bcs::from_bytes(script.args().get(1)?).ok()?,
                value: bcs::from_bytes(script.args().get(2)?).ok()?,
                description: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn donor_voice_txs_propose_liquidate_tx(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DonorVoiceTxsProposeLiquidateTx {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn donor_voice_txs_propose_payment_tx(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DonorVoiceTxsProposePaymentTx {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                payee: bcs::from_bytes(script.args().get(1)?).ok()?,
                value: bcs::from_bytes(script.args().get(2)?).ok()?,
                description: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn donor_voice_txs_propose_veto_tx(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DonorVoiceTxsProposeVetoTx {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                id: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn donor_voice_txs_vote_liquidation_tx(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DonorVoiceTxsVoteLiquidationTx {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn donor_voice_txs_vote_reauth_tx(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DonorVoiceTxsVoteReauthTx {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn epoch_boundary_smoke_enable_trigger(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::EpochBoundarySmokeEnableTrigger {})
        } else {
            None
        }
    }

    pub fn epoch_boundary_smoke_trigger_epoch(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::EpochBoundarySmokeTriggerEpoch {})
        } else {
            None
        }
    }

    pub fn filo_migration_maybe_migrate(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::FiloMigrationMaybeMigrate {})
        } else {
            None
        }
    }

    pub fn jail_unjail_by_voucher(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::JailUnjailByVoucher {
                addr: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn libra_coin_mint_to_impl(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::LibraCoinMintToImpl {
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multi_action_claim_offer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultiActionClaimOffer {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multi_action_init_gov_deprecated(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::MultiActionInitGovDeprecated {})
        } else {
            None
        }
    }

    pub fn multisig_account_add_owner(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountAddOwner {
                new_owner: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_add_owners(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountAddOwners {
                new_owners: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_remove_owner(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountRemoveOwner {
                owner_to_remove: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_remove_owners(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountRemoveOwners {
                owners_to_remove: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_update_metadata(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountUpdateMetadata {
                keys: bcs::from_bytes(script.args().get(0)?).ok()?,
                values: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_update_signatures_required(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountUpdateSignaturesRequired {
                new_num_signatures_required: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn ol_account_create_account(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::OlAccountCreateAccount {
                auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn ol_account_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::OlAccountTransfer {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn proof_of_fee_pof_retract_bid(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::ProofOfFeePofRetractBid {})
        } else {
            None
        }
    }

    pub fn proof_of_fee_pof_update_bid(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ProofOfFeePofUpdateBid {
                bid: bcs::from_bytes(script.args().get(0)?).ok()?,
                epoch_expiry: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn proof_of_fee_pof_update_bid_net_reward(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ProofOfFeePofUpdateBidNetReward {
                net_reward: bcs::from_bytes(script.args().get(0)?).ok()?,
                epoch_expiry: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn slow_wallet_smoke_test_vm_unlock(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SlowWalletSmokeTestVmUnlock {
                user_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                unlocked: bcs::from_bytes(script.args().get(1)?).ok()?,
                transferred: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn slow_wallet_user_set_slow(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::SlowWalletUserSetSlow {})
        } else {
            None
        }
    }

    pub fn stake_initialize_validator(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeInitializeValidator {
                consensus_pubkey: bcs::from_bytes(script.args().get(0)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(1)?).ok()?,
                network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                fullnode_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_update_network_and_fullnode_addresses(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeUpdateNetworkAndFullnodeAddresses {
                validator_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_network_addresses: bcs::from_bytes(script.args().get(1)?).ok()?,
                new_fullnode_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_universe_register_validator(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorUniverseRegisterValidator {
                consensus_pubkey: bcs::from_bytes(script.args().get(0)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(1)?).ok()?,
                network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                fullnode_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn vouch_txs_clean_expired(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::VouchTxsCleanExpired {})
        } else {
            None
        }
    }

    pub fn vouch_txs_revoke(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::VouchTxsRevoke {
                friend_account: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn vouch_txs_vouch_for(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::VouchTxsVouchFor {
                friend_account: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }
}

type EntryFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: EntryFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "account_offer_rotation_capability".to_string(),
            Box::new(decoder::account_offer_rotation_capability),
        );
        map.insert(
            "account_revoke_rotation_capability".to_string(),
            Box::new(decoder::account_revoke_rotation_capability),
        );
        map.insert(
            "account_rotate_authentication_key".to_string(),
            Box::new(decoder::account_rotate_authentication_key),
        );
        map.insert(
            "account_rotate_authentication_key_with_rotation_capability".to_string(),
            Box::new(decoder::account_rotate_authentication_key_with_rotation_capability),
        );
        map.insert(
            "burn_set_send_community".to_string(),
            Box::new(decoder::burn_set_send_community),
        );
        map.insert(
            "code_publish_package_txn".to_string(),
            Box::new(decoder::code_publish_package_txn),
        );
        map.insert(
            "coin_transfer".to_string(),
            Box::new(decoder::coin_transfer),
        );
        map.insert(
            "community_wallet_init_change_signer_community_multisig".to_string(),
            Box::new(decoder::community_wallet_init_change_signer_community_multisig),
        );
        map.insert(
            "community_wallet_init_finalize_and_cage".to_string(),
            Box::new(decoder::community_wallet_init_finalize_and_cage),
        );
        map.insert(
            "community_wallet_init_init_community".to_string(),
            Box::new(decoder::community_wallet_init_init_community),
        );
        map.insert(
            "community_wallet_init_propose_offer".to_string(),
            Box::new(decoder::community_wallet_init_propose_offer),
        );
        map.insert(
            "diem_governance_ol_create_proposal_v2".to_string(),
            Box::new(decoder::diem_governance_ol_create_proposal_v2),
        );
        map.insert(
            "diem_governance_ol_vote".to_string(),
            Box::new(decoder::diem_governance_ol_vote),
        );
        map.insert(
            "diem_governance_smoke_trigger_epoch".to_string(),
            Box::new(decoder::diem_governance_smoke_trigger_epoch),
        );
        map.insert(
            "diem_governance_trigger_epoch".to_string(),
            Box::new(decoder::diem_governance_trigger_epoch),
        );
        map.insert(
            "donor_voice_txs_maybe_tally_reauth_tx".to_string(),
            Box::new(decoder::donor_voice_txs_maybe_tally_reauth_tx),
        );
        map.insert(
            "donor_voice_txs_propose_advance_tx".to_string(),
            Box::new(decoder::donor_voice_txs_propose_advance_tx),
        );
        map.insert(
            "donor_voice_txs_propose_liquidate_tx".to_string(),
            Box::new(decoder::donor_voice_txs_propose_liquidate_tx),
        );
        map.insert(
            "donor_voice_txs_propose_payment_tx".to_string(),
            Box::new(decoder::donor_voice_txs_propose_payment_tx),
        );
        map.insert(
            "donor_voice_txs_propose_veto_tx".to_string(),
            Box::new(decoder::donor_voice_txs_propose_veto_tx),
        );
        map.insert(
            "donor_voice_txs_vote_liquidation_tx".to_string(),
            Box::new(decoder::donor_voice_txs_vote_liquidation_tx),
        );
        map.insert(
            "donor_voice_txs_vote_reauth_tx".to_string(),
            Box::new(decoder::donor_voice_txs_vote_reauth_tx),
        );
        map.insert(
            "epoch_boundary_smoke_enable_trigger".to_string(),
            Box::new(decoder::epoch_boundary_smoke_enable_trigger),
        );
        map.insert(
            "epoch_boundary_smoke_trigger_epoch".to_string(),
            Box::new(decoder::epoch_boundary_smoke_trigger_epoch),
        );
        map.insert(
            "filo_migration_maybe_migrate".to_string(),
            Box::new(decoder::filo_migration_maybe_migrate),
        );
        map.insert(
            "jail_unjail_by_voucher".to_string(),
            Box::new(decoder::jail_unjail_by_voucher),
        );
        map.insert(
            "libra_coin_mint_to_impl".to_string(),
            Box::new(decoder::libra_coin_mint_to_impl),
        );
        map.insert(
            "multi_action_claim_offer".to_string(),
            Box::new(decoder::multi_action_claim_offer),
        );
        map.insert(
            "multi_action_init_gov_deprecated".to_string(),
            Box::new(decoder::multi_action_init_gov_deprecated),
        );
        map.insert(
            "multisig_account_add_owner".to_string(),
            Box::new(decoder::multisig_account_add_owner),
        );
        map.insert(
            "multisig_account_add_owners".to_string(),
            Box::new(decoder::multisig_account_add_owners),
        );
        map.insert(
            "multisig_account_remove_owner".to_string(),
            Box::new(decoder::multisig_account_remove_owner),
        );
        map.insert(
            "multisig_account_remove_owners".to_string(),
            Box::new(decoder::multisig_account_remove_owners),
        );
        map.insert(
            "multisig_account_update_metadata".to_string(),
            Box::new(decoder::multisig_account_update_metadata),
        );
        map.insert(
            "multisig_account_update_signatures_required".to_string(),
            Box::new(decoder::multisig_account_update_signatures_required),
        );
        map.insert(
            "ol_account_create_account".to_string(),
            Box::new(decoder::ol_account_create_account),
        );
        map.insert(
            "ol_account_transfer".to_string(),
            Box::new(decoder::ol_account_transfer),
        );
        map.insert(
            "proof_of_fee_pof_retract_bid".to_string(),
            Box::new(decoder::proof_of_fee_pof_retract_bid),
        );
        map.insert(
            "proof_of_fee_pof_update_bid".to_string(),
            Box::new(decoder::proof_of_fee_pof_update_bid),
        );
        map.insert(
            "proof_of_fee_pof_update_bid_net_reward".to_string(),
            Box::new(decoder::proof_of_fee_pof_update_bid_net_reward),
        );
        map.insert(
            "slow_wallet_smoke_test_vm_unlock".to_string(),
            Box::new(decoder::slow_wallet_smoke_test_vm_unlock),
        );
        map.insert(
            "slow_wallet_user_set_slow".to_string(),
            Box::new(decoder::slow_wallet_user_set_slow),
        );
        map.insert(
            "stake_initialize_validator".to_string(),
            Box::new(decoder::stake_initialize_validator),
        );
        map.insert(
            "stake_update_network_and_fullnode_addresses".to_string(),
            Box::new(decoder::stake_update_network_and_fullnode_addresses),
        );
        map.insert(
            "validator_universe_register_validator".to_string(),
            Box::new(decoder::validator_universe_register_validator),
        );
        map.insert(
            "vouch_txs_clean_expired".to_string(),
            Box::new(decoder::vouch_txs_clean_expired),
        );
        map.insert(
            "vouch_txs_revoke".to_string(),
            Box::new(decoder::vouch_txs_revoke),
        );
        map.insert(
            "vouch_txs_vouch_for".to_string(),
            Box::new(decoder::vouch_txs_vouch_for),
        );
        map
    });
