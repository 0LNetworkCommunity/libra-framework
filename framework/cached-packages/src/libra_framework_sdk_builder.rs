// Copyright Â© Diem Foundation
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Diem transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `diem-sdk-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(clippy::too_many_arguments)]
use diem_types::{
    account_address::AccountAddress,
    transaction::{EntryFunction, TransactionPayload},
};
use move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {
    /// User opts into burns being sent to community (recycle burn).
    /// default is false (burn is final).
    BurnSetSendCommunity {
        community: bool,
    },

    /// Same as `publish_package` but as an entry function which can be called as a transaction. Because
    /// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
    CodePublishPackageTxn {
        metadata_serialized: Vec<u8>,
        code: Vec<Vec<u8>>,
    },

    /// Transfers `amount` of coins `CoinType` from `from` to `to`.
    CoinTransfer {
        coin_type: TypeTag,
        to: AccountAddress,
        amount: u64,
    },

    /// TODO: Allow to propose change only on the signature threshold
    /// Add or remove a signer to/from the multisig, and check if they may be related in the ancestry tree
    CommunityWalletInitChangeSignerCommunityMultisig {
        multisig_address: AccountAddress,
        new_signer: AccountAddress,
        is_add_operation: bool,
        n_of_m: u64,
        vote_duration_epochs: u64,
    },

    /// convenience function to check if the account can be caged
    /// after all the structs are in place
    CommunityWalletInitFinalizeAndCage {
        num_signers: u64,
    },

    CommunityWalletInitInitCommunity {
        initial_authorities: Vec<AccountAddress>,
        check_threshold: u64,
    },

    /// Propose offer to the multisig, and check if the signers are not related family
    CommunityWalletInitProposeOffer {
        new_signers: Vec<AccountAddress>,
        num_signers: u64,
    },

    /// Create a single-step or multi-step proposal
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
    /// only the exact script with matching hash can be successfully executed.
    DiemGovernanceOlCreateProposalV2 {
        execution_hash: Vec<u8>,
        metadata_location: Vec<u8>,
        metadata_hash: Vec<u8>,
        is_multi_step_proposal: bool,
    },

    /// Vote on proposal with `proposal_id`.
    DiemGovernanceOlVote {
        proposal_id: u64,
        should_pass: bool,
    },

    DiemGovernanceSmokeTriggerEpoch {},

    /// After proposed, subsequent voters call this to vote liquidation
    DonorVoiceTxsVoteLiquidationTx {
        multisig_address: AccountAddress,
    },

    EpochBoundarySmokeTriggerEpoch {},

    FiloMigrationMaybeMigrate {},

    /// Only a Voucher of the validator can flip the unjail bit.
    /// This is a way to make sure the validator is ready to rejoin.
    JailUnjailByVoucher {
        addr: AccountAddress,
    },

    /// Root account can mint to an address. Only used for genesis and tests.
    /// The "root" account in smoke tests has some privileges.
    LibraCoinMintToImpl {
        dst_addr: AccountAddress,
        amount: u64,
    },

    MultiActionClaimOffer {
        multisig_address: AccountAddress,
    },

    MultiActionInitGovDeprecated {},

    /// Similar to add_owners, but only allow adding one owner.
    MultisigAccountAddOwner {
        new_owner: AccountAddress,
    },

    /// Add new owners to the multisig account. This can only be invoked by the multisig account itself, through the
    /// proposal flow.
    ///
    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
    /// maliciously alter the owners list.
    MultisigAccountAddOwners {
        new_owners: Vec<AccountAddress>,
    },

    /// Similar to remove_owners, but only allow removing one owner.
    MultisigAccountRemoveOwner {
        owner_to_remove: AccountAddress,
    },

    /// Remove owners from the multisig account. This can only be invoked by the multisig account itself, through the
    /// proposal flow.
    ///
    /// This function skips any owners who are not in the multisig account's list of owners.
    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
    /// maliciously alter the owners list.
    MultisigAccountRemoveOwners {
        owners_to_remove: Vec<AccountAddress>,
    },

    /// Allow the multisig account to update its own metadata. Note that this overrides the entire existing metadata.
    /// If any attributes are not specified in the metadata, they will be removed!
    ///
    /// This can only be invoked by the multisig account itself, through the proposal flow.
    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
    /// maliciously alter the number of signatures required.
    MultisigAccountUpdateMetadata {
        keys: Vec<Vec<u8>>,
        values: Vec<Vec<u8>>,
    },

    /// Update the number of signatures required to execute transaction in the specified multisig account.
    ///
    /// This can only be invoked by the multisig account itself, through the proposal flow.
    /// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
    /// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
    /// maliciously alter the number of signatures required.
    MultisigAccountUpdateSignaturesRequired {
        new_num_signatures_required: u64,
    },

    /// Helper for smoke tests to create accounts.
    /// this is in production code because:
    /// it is used for genesis transactions regarding mainnet
    /// e.g. test_correct_supply_arithmetic_single
    /// plus, a  #[test_only] pragma will not work for smoke tests
    /// Belt and suspenders
    OlAccountCreateAccount {
        auth_key: AccountAddress,
    },

    /// Convenient function to transfer GAS to a recipient account that might not exist.
    /// This would create the recipient account first, which also registers it to receive GAS, before transferring.
    OlAccountTransfer {
        to: AccountAddress,
        amount: u64,
    },

    /// retract bid
    ProofOfFeePofRetractBid {},

    /// update the bid for the sender
    ProofOfFeePofUpdateBid {
        bid: u64,
        epoch_expiry: u64,
    },

    SlowWalletSmokeTestVmUnlock {
        user_addr: AccountAddress,
        unlocked: u64,
        transferred: u64,
    },

    /// Users can change their account to slow, by calling the entry function
    /// Warning: this is permanent for the account. There's no way to
    /// reverse a "slow wallet".
    SlowWalletUserSetSlow {},

    /// Initialize the validator account and give ownership to the signing account.
    StakeInitializeValidator {
        consensus_pubkey: Vec<u8>,
        proof_of_possession: Vec<u8>,
        network_addresses: Vec<u8>,
        fullnode_addresses: Vec<u8>,
    },

    /// This is the entrypoint for a validator joining the network.
    /// Separates the logic of registration from validator election etc. (in stake.move).
    /// This prevents dependency cycling issues, since stake.move is a large module.
    ValidatorUniverseRegisterValidator {
        consensus_pubkey: Vec<u8>,
        proof_of_possession: Vec<u8>,
        network_addresses: Vec<u8>,
        fullnode_addresses: Vec<u8>,
    },

    VouchTxsCleanExpired {},

    VouchTxsRevoke {
        friend_account: AccountAddress,
    },

    VouchTxsVouchFor {
        friend_account: AccountAddress,
    },
}

impl EntryFunctionCall {
    /// Build an Diem `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            BurnSetSendCommunity { community } => burn_set_send_community(community),
            CodePublishPackageTxn {
                metadata_serialized,
                code,
            } => code_publish_package_txn(metadata_serialized, code),
            CoinTransfer {
                coin_type,
                to,
                amount,
            } => coin_transfer(coin_type, to, amount),
            CommunityWalletInitChangeSignerCommunityMultisig {
                multisig_address,
                new_signer,
                is_add_operation,
                n_of_m,
                vote_duration_epochs,
            } => community_wallet_init_change_signer_community_multisig(
                multisig_address,
                new_signer,
                is_add_operation,
                n_of_m,
                vote_duration_epochs,
            ),
            CommunityWalletInitFinalizeAndCage { num_signers } => {
                community_wallet_init_finalize_and_cage(num_signers)
            }
            CommunityWalletInitInitCommunity {
                initial_authorities,
                check_threshold,
            } => community_wallet_init_init_community(initial_authorities, check_threshold),
            CommunityWalletInitProposeOffer {
                new_signers,
                num_signers,
            } => community_wallet_init_propose_offer(new_signers, num_signers),
            DiemGovernanceOlCreateProposalV2 {
                execution_hash,
                metadata_location,
                metadata_hash,
                is_multi_step_proposal,
            } => diem_governance_ol_create_proposal_v2(
                execution_hash,
                metadata_location,
                metadata_hash,
                is_multi_step_proposal,
            ),
            DiemGovernanceOlVote {
                proposal_id,
                should_pass,
            } => diem_governance_ol_vote(proposal_id, should_pass),
            DiemGovernanceSmokeTriggerEpoch {} => diem_governance_smoke_trigger_epoch(),
            DonorVoiceTxsVoteLiquidationTx { multisig_address } => {
                donor_voice_txs_vote_liquidation_tx(multisig_address)
            }
            EpochBoundarySmokeTriggerEpoch {} => epoch_boundary_smoke_trigger_epoch(),
            FiloMigrationMaybeMigrate {} => filo_migration_maybe_migrate(),
            JailUnjailByVoucher { addr } => jail_unjail_by_voucher(addr),
            LibraCoinMintToImpl { dst_addr, amount } => libra_coin_mint_to_impl(dst_addr, amount),
            MultiActionClaimOffer { multisig_address } => {
                multi_action_claim_offer(multisig_address)
            }
            MultiActionInitGovDeprecated {} => multi_action_init_gov_deprecated(),
            MultisigAccountAddOwner { new_owner } => multisig_account_add_owner(new_owner),
            MultisigAccountAddOwners { new_owners } => multisig_account_add_owners(new_owners),
            MultisigAccountRemoveOwner { owner_to_remove } => {
                multisig_account_remove_owner(owner_to_remove)
            }
            MultisigAccountRemoveOwners { owners_to_remove } => {
                multisig_account_remove_owners(owners_to_remove)
            }
            MultisigAccountUpdateMetadata { keys, values } => {
                multisig_account_update_metadata(keys, values)
            }
            MultisigAccountUpdateSignaturesRequired {
                new_num_signatures_required,
            } => multisig_account_update_signatures_required(new_num_signatures_required),
            OlAccountCreateAccount { auth_key } => ol_account_create_account(auth_key),
            OlAccountTransfer { to, amount } => ol_account_transfer(to, amount),
            ProofOfFeePofRetractBid {} => proof_of_fee_pof_retract_bid(),
            ProofOfFeePofUpdateBid { bid, epoch_expiry } => {
                proof_of_fee_pof_update_bid(bid, epoch_expiry)
            }
            SlowWalletSmokeTestVmUnlock {
                user_addr,
                unlocked,
                transferred,
            } => slow_wallet_smoke_test_vm_unlock(user_addr, unlocked, transferred),
            SlowWalletUserSetSlow {} => slow_wallet_user_set_slow(),
            StakeInitializeValidator {
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            } => stake_initialize_validator(
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            ),
            ValidatorUniverseRegisterValidator {
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            } => validator_universe_register_validator(
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            ),
            VouchTxsCleanExpired {} => vouch_txs_clean_expired(),
            VouchTxsRevoke { friend_account } => vouch_txs_revoke(friend_account),
            VouchTxsVouchFor { friend_account } => vouch_txs_vouch_for(friend_account),
        }
    }

    /// Try to recognize an Diem `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// User opts into burns being sent to community (recycle burn).
/// default is false (burn is final).
pub fn burn_set_send_community(community: bool) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("burn").to_owned(),
        ),
        ident_str!("set_send_community").to_owned(),
        vec![],
        vec![bcs::to_bytes(&community).unwrap()],
    ))
}

/// Same as `publish_package` but as an entry function which can be called as a transaction. Because
/// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
pub fn code_publish_package_txn(
    metadata_serialized: Vec<u8>,
    code: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("code").to_owned(),
        ),
        ident_str!("publish_package_txn").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&metadata_serialized).unwrap(),
            bcs::to_bytes(&code).unwrap(),
        ],
    ))
}

/// Transfers `amount` of coins `CoinType` from `from` to `to`.
pub fn coin_transfer(coin_type: TypeTag, to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// TODO: Allow to propose change only on the signature threshold
/// Add or remove a signer to/from the multisig, and check if they may be related in the ancestry tree
pub fn community_wallet_init_change_signer_community_multisig(
    multisig_address: AccountAddress,
    new_signer: AccountAddress,
    is_add_operation: bool,
    n_of_m: u64,
    vote_duration_epochs: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("community_wallet_init").to_owned(),
        ),
        ident_str!("change_signer_community_multisig").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&multisig_address).unwrap(),
            bcs::to_bytes(&new_signer).unwrap(),
            bcs::to_bytes(&is_add_operation).unwrap(),
            bcs::to_bytes(&n_of_m).unwrap(),
            bcs::to_bytes(&vote_duration_epochs).unwrap(),
        ],
    ))
}

/// convenience function to check if the account can be caged
/// after all the structs are in place
pub fn community_wallet_init_finalize_and_cage(num_signers: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("community_wallet_init").to_owned(),
        ),
        ident_str!("finalize_and_cage").to_owned(),
        vec![],
        vec![bcs::to_bytes(&num_signers).unwrap()],
    ))
}

pub fn community_wallet_init_init_community(
    initial_authorities: Vec<AccountAddress>,
    check_threshold: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("community_wallet_init").to_owned(),
        ),
        ident_str!("init_community").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&initial_authorities).unwrap(),
            bcs::to_bytes(&check_threshold).unwrap(),
        ],
    ))
}

/// Propose offer to the multisig, and check if the signers are not related family
pub fn community_wallet_init_propose_offer(
    new_signers: Vec<AccountAddress>,
    num_signers: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("community_wallet_init").to_owned(),
        ),
        ident_str!("propose_offer").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&new_signers).unwrap(),
            bcs::to_bytes(&num_signers).unwrap(),
        ],
    ))
}

/// Create a single-step or multi-step proposal
/// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
/// only the exact script with matching hash can be successfully executed.
pub fn diem_governance_ol_create_proposal_v2(
    execution_hash: Vec<u8>,
    metadata_location: Vec<u8>,
    metadata_hash: Vec<u8>,
    is_multi_step_proposal: bool,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("diem_governance").to_owned(),
        ),
        ident_str!("ol_create_proposal_v2").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&execution_hash).unwrap(),
            bcs::to_bytes(&metadata_location).unwrap(),
            bcs::to_bytes(&metadata_hash).unwrap(),
            bcs::to_bytes(&is_multi_step_proposal).unwrap(),
        ],
    ))
}

/// Vote on proposal with `proposal_id`.
pub fn diem_governance_ol_vote(proposal_id: u64, should_pass: bool) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("diem_governance").to_owned(),
        ),
        ident_str!("ol_vote").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&proposal_id).unwrap(),
            bcs::to_bytes(&should_pass).unwrap(),
        ],
    ))
}

pub fn diem_governance_smoke_trigger_epoch() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("diem_governance").to_owned(),
        ),
        ident_str!("smoke_trigger_epoch").to_owned(),
        vec![],
        vec![],
    ))
}

/// After proposed, subsequent voters call this to vote liquidation
pub fn donor_voice_txs_vote_liquidation_tx(multisig_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("donor_voice_txs").to_owned(),
        ),
        ident_str!("vote_liquidation_tx").to_owned(),
        vec![],
        vec![bcs::to_bytes(&multisig_address).unwrap()],
    ))
}

pub fn epoch_boundary_smoke_trigger_epoch() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("epoch_boundary").to_owned(),
        ),
        ident_str!("smoke_trigger_epoch").to_owned(),
        vec![],
        vec![],
    ))
}

pub fn filo_migration_maybe_migrate() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("filo_migration").to_owned(),
        ),
        ident_str!("maybe_migrate").to_owned(),
        vec![],
        vec![],
    ))
}

/// Only a Voucher of the validator can flip the unjail bit.
/// This is a way to make sure the validator is ready to rejoin.
pub fn jail_unjail_by_voucher(addr: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("jail").to_owned(),
        ),
        ident_str!("unjail_by_voucher").to_owned(),
        vec![],
        vec![bcs::to_bytes(&addr).unwrap()],
    ))
}

/// Root account can mint to an address. Only used for genesis and tests.
/// The "root" account in smoke tests has some privileges.
pub fn libra_coin_mint_to_impl(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("libra_coin").to_owned(),
        ),
        ident_str!("mint_to_impl").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn multi_action_claim_offer(multisig_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multi_action").to_owned(),
        ),
        ident_str!("claim_offer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&multisig_address).unwrap()],
    ))
}

pub fn multi_action_init_gov_deprecated() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multi_action").to_owned(),
        ),
        ident_str!("init_gov_deprecated").to_owned(),
        vec![],
        vec![],
    ))
}

/// Similar to add_owners, but only allow adding one owner.
pub fn multisig_account_add_owner(new_owner: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("add_owner").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_owner).unwrap()],
    ))
}

/// Add new owners to the multisig account. This can only be invoked by the multisig account itself, through the
/// proposal flow.
///
/// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
/// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
/// maliciously alter the owners list.
pub fn multisig_account_add_owners(new_owners: Vec<AccountAddress>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("add_owners").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_owners).unwrap()],
    ))
}

/// Similar to remove_owners, but only allow removing one owner.
pub fn multisig_account_remove_owner(owner_to_remove: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("remove_owner").to_owned(),
        vec![],
        vec![bcs::to_bytes(&owner_to_remove).unwrap()],
    ))
}

/// Remove owners from the multisig account. This can only be invoked by the multisig account itself, through the
/// proposal flow.
///
/// This function skips any owners who are not in the multisig account's list of owners.
/// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
/// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
/// maliciously alter the owners list.
pub fn multisig_account_remove_owners(owners_to_remove: Vec<AccountAddress>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("remove_owners").to_owned(),
        vec![],
        vec![bcs::to_bytes(&owners_to_remove).unwrap()],
    ))
}

/// Allow the multisig account to update its own metadata. Note that this overrides the entire existing metadata.
/// If any attributes are not specified in the metadata, they will be removed!
///
/// This can only be invoked by the multisig account itself, through the proposal flow.
/// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
/// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
/// maliciously alter the number of signatures required.
pub fn multisig_account_update_metadata(
    keys: Vec<Vec<u8>>,
    values: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("update_metadata").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&keys).unwrap(),
            bcs::to_bytes(&values).unwrap(),
        ],
    ))
}

/// Update the number of signatures required to execute transaction in the specified multisig account.
///
/// This can only be invoked by the multisig account itself, through the proposal flow.
/// Note that this function is not public so it can only be invoked directly instead of via a module or script. This
/// ensures that a multisig transaction cannot lead to another module obtaining the multisig signer and using it to
/// maliciously alter the number of signatures required.
pub fn multisig_account_update_signatures_required(
    new_num_signatures_required: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("multisig_account").to_owned(),
        ),
        ident_str!("update_signatures_required").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_num_signatures_required).unwrap()],
    ))
}

/// Helper for smoke tests to create accounts.
/// this is in production code because:
/// it is used for genesis transactions regarding mainnet
/// e.g. test_correct_supply_arithmetic_single
/// plus, a  #[test_only] pragma will not work for smoke tests
/// Belt and suspenders
pub fn ol_account_create_account(auth_key: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("ol_account").to_owned(),
        ),
        ident_str!("create_account").to_owned(),
        vec![],
        vec![bcs::to_bytes(&auth_key).unwrap()],
    ))
}

/// Convenient function to transfer GAS to a recipient account that might not exist.
/// This would create the recipient account first, which also registers it to receive GAS, before transferring.
pub fn ol_account_transfer(to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("ol_account").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// retract bid
pub fn proof_of_fee_pof_retract_bid() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("proof_of_fee").to_owned(),
        ),
        ident_str!("pof_retract_bid").to_owned(),
        vec![],
        vec![],
    ))
}

/// update the bid for the sender
pub fn proof_of_fee_pof_update_bid(bid: u64, epoch_expiry: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("proof_of_fee").to_owned(),
        ),
        ident_str!("pof_update_bid").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&bid).unwrap(),
            bcs::to_bytes(&epoch_expiry).unwrap(),
        ],
    ))
}

pub fn slow_wallet_smoke_test_vm_unlock(
    user_addr: AccountAddress,
    unlocked: u64,
    transferred: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("slow_wallet").to_owned(),
        ),
        ident_str!("smoke_test_vm_unlock").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&user_addr).unwrap(),
            bcs::to_bytes(&unlocked).unwrap(),
            bcs::to_bytes(&transferred).unwrap(),
        ],
    ))
}

/// Users can change their account to slow, by calling the entry function
/// Warning: this is permanent for the account. There's no way to
/// reverse a "slow wallet".
pub fn slow_wallet_user_set_slow() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("slow_wallet").to_owned(),
        ),
        ident_str!("user_set_slow").to_owned(),
        vec![],
        vec![],
    ))
}

/// Initialize the validator account and give ownership to the signing account.
pub fn stake_initialize_validator(
    consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
    network_addresses: Vec<u8>,
    fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("initialize_validator").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&network_addresses).unwrap(),
            bcs::to_bytes(&fullnode_addresses).unwrap(),
        ],
    ))
}

/// This is the entrypoint for a validator joining the network.
/// Separates the logic of registration from validator election etc. (in stake.move).
/// This prevents dependency cycling issues, since stake.move is a large module.
pub fn validator_universe_register_validator(
    consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
    network_addresses: Vec<u8>,
    fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_universe").to_owned(),
        ),
        ident_str!("register_validator").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&network_addresses).unwrap(),
            bcs::to_bytes(&fullnode_addresses).unwrap(),
        ],
    ))
}

pub fn vouch_txs_clean_expired() -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("vouch_txs").to_owned(),
        ),
        ident_str!("clean_expired").to_owned(),
        vec![],
        vec![],
    ))
}

pub fn vouch_txs_revoke(friend_account: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("vouch_txs").to_owned(),
        ),
        ident_str!("revoke").to_owned(),
        vec![],
        vec![bcs::to_bytes(&friend_account).unwrap()],
    ))
}

pub fn vouch_txs_vouch_for(friend_account: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("vouch_txs").to_owned(),
        ),
        ident_str!("vouch_for").to_owned(),
        vec![],
        vec![bcs::to_bytes(&friend_account).unwrap()],
    ))
}
mod decoder {
    use super::*;
    pub fn burn_set_send_community(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::BurnSetSendCommunity {
                community: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn code_publish_package_txn(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CodePublishPackageTxn {
                metadata_serialized: bcs::from_bytes(script.args().get(0)?).ok()?,
                code: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinTransfer {
                coin_type: script.ty_args().get(0)?.clone(),
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn community_wallet_init_change_signer_community_multisig(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(
                EntryFunctionCall::CommunityWalletInitChangeSignerCommunityMultisig {
                    multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    new_signer: bcs::from_bytes(script.args().get(1)?).ok()?,
                    is_add_operation: bcs::from_bytes(script.args().get(2)?).ok()?,
                    n_of_m: bcs::from_bytes(script.args().get(3)?).ok()?,
                    vote_duration_epochs: bcs::from_bytes(script.args().get(4)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn community_wallet_init_finalize_and_cage(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CommunityWalletInitFinalizeAndCage {
                num_signers: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn community_wallet_init_init_community(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CommunityWalletInitInitCommunity {
                initial_authorities: bcs::from_bytes(script.args().get(0)?).ok()?,
                check_threshold: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn community_wallet_init_propose_offer(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CommunityWalletInitProposeOffer {
                new_signers: bcs::from_bytes(script.args().get(0)?).ok()?,
                num_signers: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn diem_governance_ol_create_proposal_v2(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DiemGovernanceOlCreateProposalV2 {
                execution_hash: bcs::from_bytes(script.args().get(0)?).ok()?,
                metadata_location: bcs::from_bytes(script.args().get(1)?).ok()?,
                metadata_hash: bcs::from_bytes(script.args().get(2)?).ok()?,
                is_multi_step_proposal: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn diem_governance_ol_vote(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DiemGovernanceOlVote {
                proposal_id: bcs::from_bytes(script.args().get(0)?).ok()?,
                should_pass: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn diem_governance_smoke_trigger_epoch(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::DiemGovernanceSmokeTriggerEpoch {})
        } else {
            None
        }
    }

    pub fn donor_voice_txs_vote_liquidation_tx(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::DonorVoiceTxsVoteLiquidationTx {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn epoch_boundary_smoke_trigger_epoch(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::EpochBoundarySmokeTriggerEpoch {})
        } else {
            None
        }
    }

    pub fn filo_migration_maybe_migrate(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::FiloMigrationMaybeMigrate {})
        } else {
            None
        }
    }

    pub fn jail_unjail_by_voucher(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::JailUnjailByVoucher {
                addr: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn libra_coin_mint_to_impl(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::LibraCoinMintToImpl {
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multi_action_claim_offer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultiActionClaimOffer {
                multisig_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multi_action_init_gov_deprecated(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::MultiActionInitGovDeprecated {})
        } else {
            None
        }
    }

    pub fn multisig_account_add_owner(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountAddOwner {
                new_owner: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_add_owners(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountAddOwners {
                new_owners: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_remove_owner(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountRemoveOwner {
                owner_to_remove: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_remove_owners(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountRemoveOwners {
                owners_to_remove: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_update_metadata(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountUpdateMetadata {
                keys: bcs::from_bytes(script.args().get(0)?).ok()?,
                values: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn multisig_account_update_signatures_required(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::MultisigAccountUpdateSignaturesRequired {
                new_num_signatures_required: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn ol_account_create_account(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::OlAccountCreateAccount {
                auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn ol_account_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::OlAccountTransfer {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn proof_of_fee_pof_retract_bid(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::ProofOfFeePofRetractBid {})
        } else {
            None
        }
    }

    pub fn proof_of_fee_pof_update_bid(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ProofOfFeePofUpdateBid {
                bid: bcs::from_bytes(script.args().get(0)?).ok()?,
                epoch_expiry: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn slow_wallet_smoke_test_vm_unlock(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::SlowWalletSmokeTestVmUnlock {
                user_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                unlocked: bcs::from_bytes(script.args().get(1)?).ok()?,
                transferred: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn slow_wallet_user_set_slow(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::SlowWalletUserSetSlow {})
        } else {
            None
        }
    }

    pub fn stake_initialize_validator(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::StakeInitializeValidator {
                consensus_pubkey: bcs::from_bytes(script.args().get(0)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(1)?).ok()?,
                network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                fullnode_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_universe_register_validator(
        payload: &TransactionPayload,
    ) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::ValidatorUniverseRegisterValidator {
                consensus_pubkey: bcs::from_bytes(script.args().get(0)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(1)?).ok()?,
                network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                fullnode_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn vouch_txs_clean_expired(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(_script) = payload {
            Some(EntryFunctionCall::VouchTxsCleanExpired {})
        } else {
            None
        }
    }

    pub fn vouch_txs_revoke(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::VouchTxsRevoke {
                friend_account: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn vouch_txs_vouch_for(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::VouchTxsVouchFor {
                friend_account: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }
}

type EntryFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: EntryFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "burn_set_send_community".to_string(),
            Box::new(decoder::burn_set_send_community),
        );
        map.insert(
            "code_publish_package_txn".to_string(),
            Box::new(decoder::code_publish_package_txn),
        );
        map.insert(
            "coin_transfer".to_string(),
            Box::new(decoder::coin_transfer),
        );
        map.insert(
            "community_wallet_init_change_signer_community_multisig".to_string(),
            Box::new(decoder::community_wallet_init_change_signer_community_multisig),
        );
        map.insert(
            "community_wallet_init_finalize_and_cage".to_string(),
            Box::new(decoder::community_wallet_init_finalize_and_cage),
        );
        map.insert(
            "community_wallet_init_init_community".to_string(),
            Box::new(decoder::community_wallet_init_init_community),
        );
        map.insert(
            "community_wallet_init_propose_offer".to_string(),
            Box::new(decoder::community_wallet_init_propose_offer),
        );
        map.insert(
            "diem_governance_ol_create_proposal_v2".to_string(),
            Box::new(decoder::diem_governance_ol_create_proposal_v2),
        );
        map.insert(
            "diem_governance_ol_vote".to_string(),
            Box::new(decoder::diem_governance_ol_vote),
        );
        map.insert(
            "diem_governance_smoke_trigger_epoch".to_string(),
            Box::new(decoder::diem_governance_smoke_trigger_epoch),
        );
        map.insert(
            "donor_voice_txs_vote_liquidation_tx".to_string(),
            Box::new(decoder::donor_voice_txs_vote_liquidation_tx),
        );
        map.insert(
            "epoch_boundary_smoke_trigger_epoch".to_string(),
            Box::new(decoder::epoch_boundary_smoke_trigger_epoch),
        );
        map.insert(
            "filo_migration_maybe_migrate".to_string(),
            Box::new(decoder::filo_migration_maybe_migrate),
        );
        map.insert(
            "jail_unjail_by_voucher".to_string(),
            Box::new(decoder::jail_unjail_by_voucher),
        );
        map.insert(
            "libra_coin_mint_to_impl".to_string(),
            Box::new(decoder::libra_coin_mint_to_impl),
        );
        map.insert(
            "multi_action_claim_offer".to_string(),
            Box::new(decoder::multi_action_claim_offer),
        );
        map.insert(
            "multi_action_init_gov_deprecated".to_string(),
            Box::new(decoder::multi_action_init_gov_deprecated),
        );
        map.insert(
            "multisig_account_add_owner".to_string(),
            Box::new(decoder::multisig_account_add_owner),
        );
        map.insert(
            "multisig_account_add_owners".to_string(),
            Box::new(decoder::multisig_account_add_owners),
        );
        map.insert(
            "multisig_account_remove_owner".to_string(),
            Box::new(decoder::multisig_account_remove_owner),
        );
        map.insert(
            "multisig_account_remove_owners".to_string(),
            Box::new(decoder::multisig_account_remove_owners),
        );
        map.insert(
            "multisig_account_update_metadata".to_string(),
            Box::new(decoder::multisig_account_update_metadata),
        );
        map.insert(
            "multisig_account_update_signatures_required".to_string(),
            Box::new(decoder::multisig_account_update_signatures_required),
        );
        map.insert(
            "ol_account_create_account".to_string(),
            Box::new(decoder::ol_account_create_account),
        );
        map.insert(
            "ol_account_transfer".to_string(),
            Box::new(decoder::ol_account_transfer),
        );
        map.insert(
            "proof_of_fee_pof_retract_bid".to_string(),
            Box::new(decoder::proof_of_fee_pof_retract_bid),
        );
        map.insert(
            "proof_of_fee_pof_update_bid".to_string(),
            Box::new(decoder::proof_of_fee_pof_update_bid),
        );
        map.insert(
            "slow_wallet_smoke_test_vm_unlock".to_string(),
            Box::new(decoder::slow_wallet_smoke_test_vm_unlock),
        );
        map.insert(
            "slow_wallet_user_set_slow".to_string(),
            Box::new(decoder::slow_wallet_user_set_slow),
        );
        map.insert(
            "stake_initialize_validator".to_string(),
            Box::new(decoder::stake_initialize_validator),
        );
        map.insert(
            "validator_universe_register_validator".to_string(),
            Box::new(decoder::validator_universe_register_validator),
        );
        map.insert(
            "vouch_txs_clean_expired".to_string(),
            Box::new(decoder::vouch_txs_clean_expired),
        );
        map.insert(
            "vouch_txs_revoke".to_string(),
            Box::new(decoder::vouch_txs_revoke),
        );
        map.insert(
            "vouch_txs_vouch_for".to_string(),
            Box::new(decoder::vouch_txs_vouch_for),
        );
        map
    });
