module ol_framework::trust_graph {
    use std::error;
    use std::signer;
    use std::vector;
    use ol_framework::page_rank_lazy;

    // Constants
    const DEFAULT_INWARD_MAX_DEPTH: u64 = 10; // Maximum depth for inward path search
    const MAX_PROCESSED_ADDRESSES: u64 = 1000; // Circuit breaker to prevent stack overflow
    const SCORE_TTL_SECONDS: u64 = 1000; // Score validity period in seconds

    // Error codes
    const ENOT_INITIALIZED: u64 = 4;

    // Find shortest path from target to any root node
    // Returns (found_path, path_length)
    // Uses cached parent path when available to avoid recomputations
    public fun find_shortest_path_to_root(target: address, current_timestamp: u64): (bool, u64) {
        let registry_addr = @0x1;
        assert!(page_rank_lazy::registry_exists(registry_addr), error::not_found(ENOT_INITIALIZED));

        // Check if target is already a root node
        if (page_rank_lazy::is_root_node(target)) {
            return (true, 0) // Path length of 0 (target is a root)
        };

        // Optimization: check if any direct voucher has a fresh shortest path
        // If so, we can just use that path + 1
        let vouchers = find_vouchers(target);
        let i = 0;
        let len = vector::length(&vouchers);

        let min_parent_path = 0xFFFFFFFFFFFFFFFF; // Start with MAX_U64
        let found_fresh_parent_path = false;

        while (i < len) {
            let voucher = *vector::borrow(&vouchers, i);

            if (page_rank_lazy::has_trust_record(voucher)) {
                // Check if this voucher has a fresh path calculation
                if (page_rank_lazy::has_fresh_path(voucher, current_timestamp)) {
                    let voucher_path = page_rank_lazy::get_shortest_path(voucher);

                    // Found a fresh path from a parent - use it if it's shorter
                    if (voucher_path < min_parent_path) {
                        min_parent_path = voucher_path;
                        found_fresh_parent_path = true;
                    }
                }
            };

            i = i + 1;
        };

        // If we found a fresh path from a parent, use it
        if (found_fresh_parent_path) {
            return (true, min_parent_path + 1)
        };

        // If no fresh parent path, perform the full breadth-first search
        // Initialize a breadth-first search from the target node
        let visited = vector::empty<address>();
        let queue = vector::empty<address>();
        let distances = vector::empty<u64>();

        // Start with the target node
        vector::push_back(&mut visited, target);
        vector::push_back(&mut queue, target);
        vector::push_back(&mut distances, 0);

        let processed_count = 0;

        while (!vector::is_empty(&queue)) {
            // Circuit breaker
            if (processed_count >= MAX_PROCESSED_ADDRESSES) {
                return (false, 0) // Path not found within processing limits
            };

            processed_count = processed_count + 1;

            // Dequeue the next node to process
            let current = vector::remove(&mut queue, 0);
            let distance = vector::remove(&mut distances, 0);

            // Don't go beyond the maximum search depth
            if (distance >= DEFAULT_INWARD_MAX_DEPTH) {
                continue
            };

            // Find all accounts that vouch for the current account (inbound edges)
            let current_vouchers = find_vouchers(current);
            let j = 0;
            let vouchers_len = vector::length(&current_vouchers);

            while (j < vouchers_len) {
                let voucher = *vector::borrow(&current_vouchers, j);

                // Check if this voucher is a root
                if (page_rank_lazy::is_root_node(voucher)) {
                    return (true, distance + 1) // Found a path to a root!
                };

                // If this voucher has a fresh path calculation, use it
                if (page_rank_lazy::has_trust_record(voucher) && !vector::contains(&visited, &voucher)) {
                    if (page_rank_lazy::has_fresh_path(voucher, current_timestamp)) {
                        let voucher_path = page_rank_lazy::get_shortest_path(voucher);

                        // Found a fresh path through this voucher
                        return (true, distance + 1 + voucher_path)
                    };

                    // Otherwise add to queue for regular BFS
                    vector::push_back(&mut visited, voucher);
                    vector::push_back(&mut queue, voucher);
                    vector::push_back(&mut distances, distance + 1);
                };

                j = j + 1;
            };
        };

        // No path found to any root node
        (false, 0)
    }

    // Find all addresses that vouch for a given address
    public fun find_vouchers(addr: address): vector<address> {
        let vouchers = vector::empty<address>();

        // Check all registered trust records
        let processed_count = 0;
        let search_addr = @0x1; // Start searching from a low address

        while (processed_count < MAX_PROCESSED_ADDRESSES) {
            if (page_rank_lazy::has_trust_record(search_addr)) {
                if (page_rank_lazy::vouches_for(search_addr, addr)) {
                    vector::push_back(&mut vouchers, search_addr);
                };
            };

            // Move to the next address to check - in a real implementation
            // we would need a more sophisticated way to iterate through
            // all addresses, but this is a simplification for the example
            search_addr = search_addr + @1;
            processed_count = processed_count + 1;
        };

        vouchers
    }

    // Calculate inward trust score based on shortest path
    public fun calculate_inward_path_score(target: address, current_timestamp: u64): u64 {
        let (path_found, path_length) = find_shortest_path_to_root(target, current_timestamp);

        if (!path_found) {
            return 0 // No path to root means no trust score
        };

        // Score decreases as path length increases
        // A direct root node gets maximum score (100)
        // Each step away from root reduces the score
        if (path_length == 0) {
            return 100 // Target is a root node
        };

        // Simple scoring function: 100 - (path_length * 10)
        // This means score decreases by 10 for each hop from root
        // Can be replaced with a more sophisticated decay function
        let score = 100 - (path_length * 10);

        // Ensure score doesn't go below zero
        if (score > 0) {
            score
        } else {
            0
        }
    }

    // Calculate and update the shortest path to root for a given address
    public fun update_shortest_path_to_root(addr: address, current_timestamp: u64): u64 {
        assert!(page_rank_lazy::registry_exists(@0x1), error::not_found(ENOT_INITIALIZED));

        // Get the shortest path
        let (path_found, path_length) = find_shortest_path_to_root(addr, current_timestamp);

        // Only update the record if it exists
        if (page_rank_lazy::has_trust_record(addr)) {
            page_rank_lazy::update_path_length(addr, path_found, path_length);
        };

        // Return the path length regardless of whether we updated the record
        if (path_found) {
            path_length
        } else {
            0xFFFFFFFFFFFFFFFF // Return MAX_U64 if no path found
        }
    }

    // Get the cached shortest path to root, calculating it if stale
    public fun get_shortest_path_to_root(addr: address, current_timestamp: u64): u64 {
        // If user has no trust record, they have no path
        if (!page_rank_lazy::has_trust_record(addr)) {
            return 0xFFFFFFFFFFFFFFFF
        };

        // Check if cached path is still valid and not stale
        if (page_rank_lazy::has_fresh_path(addr, current_timestamp)) {
            // Cache is fresh, return it
            return page_rank_lazy::get_shortest_path(addr)
        };

        // Calculate and update the path
        update_shortest_path_to_root(addr, current_timestamp)
    }

    #[test(admin = @0x1, root = @0x42, user = @0x43, user2 = @0x44, user3 = @0x45)]
    fun test_shortest_path_calculation(
        admin: signer,
        root: signer,
        user: signer,
        user2: signer,
        user3: signer
    ) {
        page_rank_lazy::setup_mock_trust_network(&admin, &root, &user, &user2, &user3);

        let current_timestamp = 1;
        let root_addr = signer::address_of(&root);
        let user_addr = signer::address_of(&user);
        let user2_addr = signer::address_of(&user2);
        let user3_addr = signer::address_of(&user3);

        // Calculate shortest paths
        let root_path = get_shortest_path_to_root(root_addr, current_timestamp);
        let user1_path = get_shortest_path_to_root(user_addr, current_timestamp);
        let user2_path = get_shortest_path_to_root(user2_addr, current_timestamp);
        let user3_path = get_shortest_path_to_root(user3_addr, current_timestamp);

        // Root is a root node, so distance is 0
        assert!(root_path == 0, 73570030);

        // User1 is directly vouched for by root, so distance is 1
        assert!(user1_path == 1, 73570031);

        // User2 is vouched for by User1, so distance is 2
        assert!(user2_path == 2, 73570032);

        // User3 is vouched for by User2, so distance is 3
        assert!(user3_path == 3, 73570033);
    }

    // Add a test for the shortest path calculation
    #[test(admin = @0x1, root = @0x42, user = @0x43, user2 = @0x44, user3 = @0x45)]
    fun test_shortest_path_calculation(
        admin: signer,
        root: signer,
        user: signer,
        user2: signer,
        user3: signer
    ) acquires UserTrustRecord {
        setup_mock_trust_network(&admin, &root, &user, &user2, &user3);

        let current_timestamp = 1;
        let root_addr = signer::address_of(&root);
        let user_addr = signer::address_of(&user);
        let user2_addr = signer::address_of(&user2);
        let user3_addr = signer::address_of(&user3);

        // Calculate shortest paths
        let root_path = get_shortest_path_to_root(root_addr, current_timestamp);
        let user1_path = get_shortest_path_to_root(user_addr, current_timestamp);
        let user2_path = get_shortest_path_to_root(user2_addr, current_timestamp);
        let user3_path = get_shortest_path_to_root(user3_addr, current_timestamp);

        // Root is a root node, so distance is 0
        assert!(root_path == 0, 73570030);

        // User1 is directly vouched for by root, so distance is 1
        assert!(user1_path == 1, 73570031);

        // User2 is vouched for by User1, so distance is 2
        assert!(user2_path == 2, 73570032);

        // User3 is vouched for by User2, so distance is 3
        assert!(user3_path == 3, 73570033);
    }


}
