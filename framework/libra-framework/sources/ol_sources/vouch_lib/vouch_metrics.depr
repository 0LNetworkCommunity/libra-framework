/*
  Vouch Metrics Module

  This module provides pure utility functions for calculating vouch quality metrics
  without directly accessing vouch data. This avoids circular dependencies between modules.

  The module only contains stateless helper functions that can be used by both
  vouch.move and page_rank_lazy.move without creating dependency cycles.
*/

module ol_framework::vouch_metrics {
    use std::option;
    use std::vector;
    use ol_framework::ancestry;

    use diem_std::debug::print;

    /// Get the score for the social distance between two accounts
    /// Score is a percentage, out of 100
    /// A higher score represents a closer social connections
    public fun social_distance(left: address, right: address): u64 {
        let opt = ancestry::get_degree(left, right);
        if (option::is_none(&opt)) {
            // please maintain social distance
            return 0
        };
        let degree = *option::borrow(&opt);
        if (degree == 0 ) {
            return 100
        };
        if (degree > 100) {
            return 0
        };

        100 / degree
    }

    /// Calculate the total social score for a user versus a list of accounts
    /// e.g. used for distance to a root of trust
    public fun calculate_total_social_score(user: address, list: &vector<address>): u64 {
        let total_score = 0;

        let i = 0;
        while (i < vector::length(list)) {
            let one_root = vector::borrow(list, i);
            let score = social_distance(*one_root, user);
            total_score = total_score + score;
            i = i + 1;
        };

        total_score
    }

    /// Calculate the total vouch quality for a user (used by founder and other modules)
    /// Uses the social distance based approach to eliminate circular dependency
    public fun calculate_total_vouch_quality(user: address): u64 {
        // Use a hardcoded default root of trust (@0x1) to avoid circular dependencies
        let root_of_trust = vector[@0x1];
        calculate_total_social_score(user, &root_of_trust)
    }

    /// Calculate the maximum number of vouches a user should be able to give based on their trust score
    public fun calculate_score_limit(account: address): u64 {
        // Calculate the quality using the social distance method
        // This avoids dependency on page_rank_lazy
        let total_quality = calculate_total_vouch_quality(account);
        print(&total_quality);

        // For accounts with low quality vouchers,
        // we restrict further how many they can vouch for
        let max_allowed = 1;

        // TODO: collect analytics data to review this
        if (total_quality >= 2 && total_quality < 200) {
            max_allowed = 3;
        } else if (total_quality >= 200 && total_quality < 400) {
            max_allowed = 5;
        } else if (total_quality >= 400) {
            max_allowed = 10;
        };

        max_allowed
    }

    /// Filter a list of addresses to include only those unrelated by ancestry
    /// This is a pure helper function that doesn't access vouch data
    public fun filter_unrelated(addresses: vector<address>): vector<address> {
        ancestry::list_unrelated(addresses)
    }
}
