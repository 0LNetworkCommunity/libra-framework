# Rescue Tool
Apply changes to a reference DB at rest.

# Uses
There are three cases:
1. Twin: replace the validator set from config files
2. Upgrade only: upgrade the framework (maybe the source in reference db is a brick, and can't do the scripts you want).
3. Run script: the framework in reference DB is usable, and we need to execute an admin transaction from a .move source


# Replace validators (Twin testnet)
```
cargo r -- --db-path ~/.libra/data/db \
register-vals \
--operator-yaml ~/.libra/operator.yaml
```
# Node files

You must update the node's files with waypoint information
and genesis transaction
This function is used to update the node's configuration files
after a successful rescue operation.
It updates the safety rules configuration with the new waypoint
and sets the genesis transaction to the latest writeset.

## Safety Rules
Safety rules save the consensus state of your node. It can be saved in three ways: memory, disk file, vault storage.
In OL we use disk files in testnet, and recommend memory for mainnet.
The testnet disk file will be called `secure_storage.json`. This file is automatically generated by the validator node upon startup. Things can go wrong if your `validator.yaml` has the wrong paths, or waypoints (especially frustrating).

If you are troubleshooting, this is what a minimum viable secure_storage.json file would look like after a node starts up with rescue patches applied.
```
{
  "owner_account": {
    "data": "GetResponse",
    "last_update": 1743183907,
    // NOTE: this is your validator's account address, public data
    "value": "c1e37325ed2e7215414b24c2bd7c7d0d3373165f403a1879c63bdd3eb63c5b25"
  },
  "safety_data": {
    "data": "GetResponse",
    "last_update": 1743183907,
    "value": {
      "epoch": 3,
      "last_voted_round": 0,
      "preferred_round": 0,
      "one_chain_round": 0,
      "last_vote": null
    }
  },
  "waypoint": {
    "data": "GetResponse",
    "last_update": 1743183907,
    // NOTE: if this value begins with `0:<hash>` then it's getting the genesis waypoint
    // and the version at which the rescue writeset happened.
    "value": "34:3565d5c59bbf6ae358d6cb8cb350006069418f44ceb57858d586ea79706481b3"
  },
  "consensus": {
    "data": "GetResponse",
    "last_update": 1743183907,
    // NOTE: this is a private key. It's not the key that signs transactions on the network
    // it's just for consensus messages. This is why you should use persist to memory (not secure_storage.json)
    // when in mainnet production.
    "value": "0x5dfa29a9dc3f7de05945c6f624d73dacf016e1016003c8138a29fc8e98f5ae12"
  }
}
```

#  Troubleshooting:
The principal issue with a node not being able to start
is that the initial tx (genesis.blob or rescue.blob)
is missing, malformed, or will not bootstrap. At this point
the process, we should have checked that a db would bootstrap.
The next issue is that maybe the node starts by it does not make progress.
You'll likely see one of these known cases:
1. My waypoint in secure_storage.json is always a genesis one prepended with zero `0:<hash>`
The node creates safety rules state at startup. In tesnet mode (OnDisk mode) it saves this to  `secure_storage.json` file. If when you look at the test file, you don't have a number higher than zero in the waypoint's header, then it means you the `validator.yaml` config file is referencing a genesis value somehow.
Check your `validator.yaml` for `base.waypoint`, and `consensus.safety_rules.initial_safety_rules_config.waypoint`: which should be the rescue waypoint (not genesis).
If this value is changing in your node.yaml somehow, set your `validator.yaml` with the operating system to read-only, to see what might be writing to it.


1. `Unable to initialize safety rules`.
Could possibly mean any kind of malformed data with safety rules, In the context of rescue operations this could mean:
  - If you see `Invalid bitvec from the multi-signature`, it's probably that the "waypoint" and "genesis-waypoint" are not set in the safety rules.
  - Maybe something is off with the NodeConfig's `consensus.safety_rules.initial_safety_rules_config` which should not be "None" in a rescue situation. The code in post_rescue_node_file_updates() should have prevented this.
  - When the node started it failed to create the safety rules in file (or in memory on mainnet).

1. `[RoundManager] SafetyRules Rejected`:
This is similar to the unable to initialize safety rules (you'll also see a `Invalid bitvec from the multi-signature`).
This message is rejecting a proposal from another validator because it does not see it in the validator list.  It likely means that your node is not starting from the right waypoint, reading the latest state.

Full error:
```
{"committed_round":0,"error":"from peer 17bb0cfbbe0a15ea72150245397bc8271e5f54bc74a55e3712ab4138e6196981\n\nCaused by:\n    0: [RoundManager] SafetyRules Rejected [id: fbb2cf85, author: (NIL), epoch: 3, round: 01, parent_id: f9a5f6ab, timestamp: 1743168891732818]\n    1: Invalid EpochChangeProof: Invalid bitvec from the multi-signature","kind":"SafetyRules","pending_votes":"PendingVotes: []","round":1}
```

After checking that the other node is in fact in the validator set, then the issue is most likely that the waypoint is not set
correctly in your node's files. NodeConfig has two places where waypoint is set: `base.waypoint` and `consensus.safety_rules.initial_safety_rules_config.waypoint`. Both of these must be set to the new waypoint.
The code in post_rescue_node_file_updates() should have set the waypoint


1. `safety_rules.rs:434 {"error":"validator_signer is not set, SafetyRules is not initialized"`: If you see this error coupled with the above errors it's a local config problem. If you see this error standalone, your node may not actually be in the validator set.

In this case it's likely that the "waypoint" and "genesis_waypoint" fields in safety rules are not set to the new waypoint (look in secure_data.json in testnet).
